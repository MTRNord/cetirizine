{"version":3,"file":"client-cf3c3aea.js","sources":["../../../src/app/sdk/api/apiTypes.ts","../../../src/app/sdk/room.ts","../../../node_modules/events/events.js","../../../node_modules/idb/build/wrap-idb-value.js","../../../node_modules/idb/build/index.js","../../../src/app/sdk/client.ts"],"sourcesContent":["export interface ILoginFlow {\n    type: string;\n}\nexport interface ILoginFlows {\n    flows: ILoginFlow[];\n}\n\nexport interface IErrorResp {\n    errcode: string;\n    error?: string;\n}\n\nexport interface IRateLimitError extends IErrorResp {\n    retry_after_ms: number;\n}\n\nexport interface ILoginResponse {\n    access_token: string;\n    device_id: string;\n    home_server?: string;\n    user_id: string;\n    expires_in_ms?: number;\n    refresh_token?: string;\n    well_known?: IWellKnown\n}\n\nexport interface ILoginParams {\n    address?: string;\n    device_id?: string;\n    identifier?: {\n        type: \"m.id.user\" | \"m.id.thirdparty\" | \"m.id.phone\";\n        user?: string;\n        medium?: string;\n        address?: string;\n        country?: string;\n        phone?: string;\n    };\n    initial_device_display_name?: string;\n    password?: string;\n    user?: string;\n    refresh_token?: string;\n    token?: string;\n    type: \"m.login.password\" | \"m.login.token\";\n}\n\nexport interface IWellKnown {\n    \"m.homeserver\": {\n        base_url: string;\n    }\n    \"m.identity_server\"?: {\n        base_url: string;\n    }\n    \"org.matrix.msc3575.proxy\"?: {\n        url: string;\n    }\n}\n\nexport interface IAccountData {\n    events?: any[];\n}\n\nexport interface IClientEventWithoutRoomId {\n    content: any;\n    event_id: string;\n    origin_server_ts: number;\n    sender: string;\n    // FIXME: Is this really meant to be optional?\n    state_key?: string;\n    type: string;\n    unsigned?: {\n        age?: number;\n        prev_content?: any;\n        redacted_because?: IClientEventWithoutRoomId;\n        transaction_id?: string;\n    }\n}\n\nexport interface ITimeline {\n    events: IClientEventWithoutRoomId[];\n    limited: boolean;\n    prev_batch: string;\n}\n\nexport interface IProfileInfo {\n    avatar_url?: string;\n    displayname?: string;\n}\n\n// Old sync\nexport interface ISyncResponse {\n    account_data?: IAccountData;\n    device_lists?: {\n        changed?: string[];\n        left?: string[];\n    };\n    device_one_time_keys_count?: {\n        [key: string]: number;\n    };\n    next_batch: string;\n    presence?: {\n        events?: any[];\n    };\n    rooms?: {\n        invite?: {\n            [key: string]: {\n                invite_state?: {\n                    events?: {\n                        content: any;\n                        sender: string;\n                        state_key: string;\n                        type: string;\n                        // Future proofing\n                        [key: string]: any;\n                    }[];\n                };\n            };\n        };\n        join?: {\n            [key: string]: {\n                account_data?: IAccountData;\n                ephemeral?: {\n                    events?: any[];\n                };\n                state?: {\n                    events: IClientEventWithoutRoomId[];\n                }\n                summary?: {\n                    \"m.heroes\": string[];\n                    \"m.joined_member_count\": number;\n                    \"m.invited_member_count\": number;\n                };\n                timeline?: ITimeline;\n                unread_notifications?: {\n                    highlight_count: number;\n                    notification_count: number;\n                };\n                unread_thread_notifications?: {\n                    [key: string]: {\n                        highlight_count: number;\n                        notification_count: number;\n                    };\n                };\n            };\n        };\n        leave?: {\n            [key: string]: {\n                state?: {\n                    events: IClientEventWithoutRoomId[];\n                };\n                account_data?: IAccountData;\n                timeline?: ITimeline;\n            };\n        };\n        knock?: {\n            [key: string]: {\n                knock_state?: {\n                    events?: {\n                        content: any;\n                        sender: string;\n                        state_key: string;\n                        type: string;\n                    }[];\n                };\n            };\n        };\n    };\n    to_device?: {\n        events?: any[];\n    };\n}\n\n// Sliding sync\nexport interface ISlidingSyncResp {\n    lists?: {\n        [key: string]: List;\n    };\n    rooms?: {\n        [key: string]: RoomJson;\n    };\n    extensions?: Extensions;\n    pos: string;\n    txn_id: string;\n}\n\nexport interface Extensions { }\n\nexport interface List {\n    ops?: (SYNC_OP | INSERT_OP | INVALIDATE_OP | DELETE_OP)[];\n    count: number;\n}\n\nexport function isSyncOp(op: any): op is SYNC_OP {\n    return op.op === \"SYNC\";\n}\n\nexport function isInsertOp(op: any): op is INSERT_OP {\n    return op.op === \"INSERT\";\n}\n\nexport function isInvalidateOp(op: any): op is INVALIDATE_OP {\n    return op.op === \"INVALIDATE\";\n}\n\nexport function isDeleteOp(op: any): op is DELETE_OP {\n    return op.op === \"DELETE\";\n}\n\nexport interface DELETE_OP {\n    op: string;\n    index: number;\n}\n\nexport interface INVALIDATE_OP {\n    op: string;\n    range: number[];\n}\n\nexport interface INSERT_OP {\n    op: string;\n    index: number;\n    room_id: string;\n}\n\nexport interface SYNC_OP {\n    op: string;\n    range: number[];\n    room_ids: string[];\n}\n\nexport interface RoomJson {\n    name?: string,\n    // List of events\n    timeline?: IRoomEvent[],\n    required_state?: IRoomStateEvent[],\n    notification_count: number,\n    highlight_count: number,\n    initial: boolean,\n    joined_count: number,\n    invited_count: number,\n    prev_batch: string,\n}\n\nexport interface IRoomEvent<Content = any> {\n    content: Content;\n    event_id: string;\n    origin_server_ts: number;\n    sender: string;\n    type: string;\n    unsigned?: any;\n}\n\nexport interface IRoomStateEvent<Content = any> extends IRoomEvent<Content> {\n    state_key: string;\n}\n\nexport interface IRoomMemberContent {\n    avatar_url?: string;\n    displayname?: string;\n    membership: \"invite\" | \"join\" | \"knock\" | \"leave\" | \"ban\";\n    is_direct?: boolean;\n}\n\nexport interface IRoomMemberEvent extends IRoomStateEvent<IRoomMemberContent> { }\n\nexport function isRoomMemberEvent(event: IRoomEvent): event is IRoomMemberEvent {\n    return event.type === \"m.room.member\";\n}\n\nexport interface IRoomCreateContent {\n    creator: string;\n    \"m.federate\"?: boolean;\n    predecessor?: {\n        room_id: string;\n        event_id: string;\n    };\n    room_version?: string;\n    type?: string;\n}\n\nexport interface IRoomCreateEvent extends IRoomStateEvent<IRoomCreateContent> { }\n\nexport function isRoomCreateEvent(event: IRoomEvent): event is IRoomCreateEvent {\n    return event.type === \"m.room.create\";\n}\n\nexport interface IThumbnailInfo {\n    h: number;\n    mimetype: string;\n    size: number;\n    w: number;\n}\n\nexport interface IImageInfo {\n    h: number;\n    mimetype: string;\n    size: number;\n    thumbnail_info?: IThumbnailInfo;\n    thumbnail_url?: string;\n    w: number;\n}\n\nexport interface IRoomAvatarContent {\n    info: IImageInfo;\n    url?: string;\n}\n\nexport interface IRoomAvatarEvent extends IRoomStateEvent<IRoomAvatarContent> { }\n\nexport function isRoomAvatarEvent(event: IRoomEvent): event is IRoomAvatarEvent {\n    return event.type === \"m.room.avatar\";\n}\n\nexport interface ISpaceChildContent {\n    via: string[];\n    order?: string;\n    suggested?: boolean;\n}\n\nexport interface ISpaceChildEvent extends IRoomStateEvent<ISpaceChildContent> { }\n\nexport function isSpaceChildEvent(event: IRoomEvent): event is ISpaceChildEvent {\n    return event.type === \"m.space.child\";\n}\n\nexport interface ISpaceParentContent {\n    via: string[];\n    canonical?: boolean;\n}\n\nexport interface ISpaceParentEvent extends IRoomStateEvent<ISpaceParentContent> { }\n\nexport function isSpaceParentEvent(event: IRoomEvent): event is ISpaceParentEvent {\n    return event.type === \"m.space.parent\";\n}","import { IRoomEvent, IRoomStateEvent, isRoomAvatarEvent, isRoomCreateEvent, isSpaceChildEvent, isSpaceParentEvent } from \"./api/apiTypes\";\n\nexport class Room {\n    private events: IRoomEvent[] = [];\n    private stateEvents: IRoomStateEvent[] = [];\n    private name?: string;\n\n    private notification_count: number = 0;\n    private notification_highlight_count: number = 0;\n    private joined_count: number = 0;\n    private invited_count: number = 0;\n\n    public windowPos: {\n        [list: string]: number\n    } = {}\n\n\n    constructor(public roomID: string, private hostname: string) { }\n\n    public addEvents(events: IRoomEvent[]) {\n        this.events.push(...events);\n    }\n\n    public addStateEvents(state: IRoomStateEvent[]) {\n        this.stateEvents.push(...state);\n    }\n\n    public getAvatarURL(): string | undefined {\n        let avatarURL: string | undefined = undefined;\n        this.stateEvents.forEach((event) => {\n            if (isRoomAvatarEvent(event)) {\n                const rawAvatarURL = event.content.url;\n                if (rawAvatarURL?.startsWith(\"mxc://\")) {\n                    avatarURL = `${this.hostname}/_matrix/media/r0/download/${rawAvatarURL.substring(6)}`;\n                }\n            }\n        });\n        return avatarURL;\n    }\n\n    public isSpace(): boolean {\n        let isSpace: boolean = false;\n        this.stateEvents.forEach((event) => {\n            if (isRoomCreateEvent(event)) {\n                isSpace = event.content.type === \"m.space\";\n            }\n        });\n        return isSpace;\n    }\n\n    public setName(name: string) {\n        this.name = name;\n    }\n\n    public getName(): string {\n        if (!this.name) {\n            return this.roomID;\n        }\n        return this.name;\n    }\n\n    public setNotificationCount(count: number) {\n        this.notification_count = count;\n    }\n\n    public getNotificationCount(): number {\n        return this.notification_count;\n    }\n\n    public setNotificationHighlightCount(count: number) {\n        this.notification_highlight_count = count;\n    }\n\n    public getNotificationHighlightCount(): number {\n        return this.notification_highlight_count;\n    }\n\n    public setJoinedCount(count: number) {\n        this.joined_count = count;\n    }\n\n    public getJoinedCount(): number {\n        return this.joined_count;\n    }\n\n    public setInvitedCount(count: number) {\n        this.invited_count = count;\n    }\n\n    public getInvitedCount(): number {\n        return this.invited_count;\n    }\n\n    public getSpaceChildrenIDs(): string[] {\n        const children: string[] = [];\n        this.stateEvents.forEach((event) => {\n            if (isSpaceChildEvent(event)) {\n                children.push(event.state_key);\n            }\n        });\n        return children;\n    }\n\n    public getSpaceParentIDs(): { roomID: string, canonical: boolean }[] {\n        const parents: { roomID: string, canonical: boolean }[] = [];\n        this.stateEvents.forEach((event) => {\n            if (isSpaceParentEvent(event)) {\n                parents.push({ roomID: event.state_key, canonical: event.content.canonical || false });\n            }\n        });\n        return parents;\n    }\n\n    public isDM(): boolean {\n        // TODO: Implement this\n        return false;\n    }\n\n    public isOnline(): boolean {\n        // TODO: Implement this\n        return false;\n    }\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import {\n    createContext,\n    useContext,\n    useEffect,\n    useState\n} from \"react\";\nimport {\n    IErrorResp,\n    ILoginFlows,\n    ILoginResponse,\n    IProfileInfo,\n    IRateLimitError,\n    IRoomEvent,\n    IRoomStateEvent,\n    ISlidingSyncResp,\n    IWellKnown,\n    isDeleteOp,\n    isInsertOp,\n    isInvalidateOp,\n    isSyncOp\n} from \"./api/apiTypes\";\nimport { Room } from \"./room\";\nimport EventEmitter from \"events\";\nimport {\n    DBSchema,\n    IDBPDatabase,\n    openDB\n} from \"idb\";\n\nexport interface MatrixClientEvents {\n    // Used to notify about changes to the room list\n    'rooms': (rooms: Set<Room>) => void;\n    //'delete': (changedCount: number) => void;\n}\n\nexport declare interface MatrixClient {\n    on<U extends keyof MatrixClientEvents>(\n        event: U, listener: MatrixClientEvents[U]\n    ): this;\n\n    emit<U extends keyof MatrixClientEvents>(\n        event: U, ...args: Parameters<MatrixClientEvents[U]>\n    ): boolean;\n}\n\ninterface MatrixDB extends DBSchema {\n    rooms: {\n        // Same as roomToRoom map\n        key: string;\n        value: {\n            windowPos: {\n                [list: string]: number;\n            };\n            roomID: string;\n            name: string;\n            notification_count: number;\n            highlight_count: number;\n            joined_count: number;\n            invited_count: number;\n            events?: IRoomEvent[];\n            stateEvents?: IRoomStateEvent[];\n            avatarUrl?: string;\n            isSpace: boolean;\n        };\n    };\n    loginInfo: {\n        // login info\n        value: {\n            userId: string;\n            device_id?: string;\n            hostname?: string;\n            slidingSyncHostname?: string;\n            access_token?: string;\n            displayName?: string;\n            avatarUrl?: string;\n        };\n        // User ID\n        key: string;\n    };\n    syncInfo: {\n        // sync info\n        value: {\n            userId: string;\n            syncPos?: string;\n            initialSync: boolean;\n            lastRanges?: { [key: string]: number[][] }; // [start, end]\n            lastTxnID?: string;\n        };\n        // User ID\n        key: string;\n    }\n}\n\nexport class MatrixClient extends EventEmitter {\n    private static _instance: MatrixClient;\n    private access_token?: string;\n    private device_id?: string;\n    public mxid?: string;\n    // Hostname including \"https://\"\n    private hostname?: string;\n    private slidingSyncHostname?: string;\n    private syncing = false;\n    private roomsInView: string[] = [];\n    private rooms: Set<Room> = new Set();\n    private syncPos?: string;\n    private initialSync = true;\n    private database?: IDBPDatabase<MatrixDB>;\n    private profileInfo?: IProfileInfo;\n    private lastRanges?: { [key: string]: number[][] };\n    private lastTxnID?: string;\n\n    public get isLoggedIn(): boolean {\n        return this.access_token !== undefined;\n    }\n\n    public static async Instance() {\n        let instance = this._instance;\n        // Load from database if not done\n        if (!instance) {\n            instance = (this._instance = new this());\n            if (!instance.database) {\n                await instance.createDatabase();\n            }\n            const tx = instance.database?.transaction('loginInfo', 'readonly');\n            // We dont know the mxid so we just get all and use the first. In theory this allows for multiple accounts\n            const loginInfo = await tx?.store.getAll();\n            await tx?.done;\n            if (loginInfo && loginInfo.length > 0) {\n                instance.mxid = loginInfo[0].userId;\n                instance.hostname = loginInfo[0].hostname;\n                instance.slidingSyncHostname = loginInfo[0].slidingSyncHostname;\n                instance.access_token = loginInfo[0].access_token;\n                instance.device_id = loginInfo[0].device_id;\n                instance.profileInfo = {\n                    avatar_url: loginInfo[0].avatarUrl,\n                    displayname: loginInfo[0].displayName,\n                };\n\n                // Load sync info\n                const syncTx = instance.database?.transaction('syncInfo', 'readonly');\n                const syncInfo = await syncTx?.store.get(instance.mxid!);\n                await syncTx?.done;\n\n                if (syncInfo) {\n                    instance.syncPos = syncInfo.syncPos;\n                    instance.initialSync = syncInfo.initialSync;\n                    instance.lastRanges = syncInfo.lastRanges;\n                    instance.lastTxnID = syncInfo.lastTxnID;\n                }\n\n                // Load rooms\n                const roomTx = instance.database?.transaction('rooms', 'readonly');\n                const rooms = await roomTx?.store.getAll();\n                await roomTx?.done;\n\n                if (rooms) {\n                    instance.rooms = new Set(rooms.map(room => {\n                        const roomObj = new Room(room.roomID, instance.hostname!);\n                        roomObj.windowPos = room.windowPos;\n                        roomObj.setInvitedCount(room.invited_count);\n                        roomObj.setJoinedCount(room.joined_count);\n                        roomObj.setNotificationCount(room.notification_count);\n                        roomObj.setNotificationHighlightCount(room.highlight_count);\n                        roomObj.setName(room.name);\n                        if (room.events) {\n                            roomObj.addEvents(room.events);\n                        }\n                        if (room.stateEvents) {\n                            roomObj.addStateEvents(room.stateEvents);\n                        }\n                        return roomObj;\n                    }))\n                    instance.emit(\"rooms\", instance.rooms);\n                }\n            }\n        }\n\n\n        return instance;\n    }\n\n    private async createDatabase() {\n        this.database = await openDB<MatrixDB>(\"matrix\", 3, {\n            upgrade(db) {\n                if (db.objectStoreNames.contains(\"rooms\")) {\n                    db.deleteObjectStore(\"rooms\");\n                }\n                //if (db.objectStoreNames.contains(\"loginInfo\")) {\n                //    db.deleteObjectStore(\"loginInfo\");\n                //}\n                if (db.objectStoreNames.contains(\"syncInfo\")) {\n                    db.deleteObjectStore(\"syncInfo\");\n                }\n                db.createObjectStore('rooms', { keyPath: 'roomID' });\n                db.createObjectStore('loginInfo', { keyPath: 'userId' });\n                db.createObjectStore('syncInfo', { keyPath: 'userId' });\n            }\n        });\n    }\n\n    private async setHostname(hostname: string) {\n        if (!hostname.startsWith(\"https://\")) {\n            throw Error(\"Hostname must start with 'https://'\");\n        }\n        if (!this.database) {\n            await this.createDatabase();\n        }\n\n        // Write to database\n        const tx = this.database?.transaction('loginInfo', 'readwrite');\n        await tx?.store.put({\n            userId: this.mxid!,\n            hostname: hostname,\n            slidingSyncHostname: this.slidingSyncHostname,\n            access_token: this.access_token,\n            device_id: this.device_id,\n        });\n        await tx?.done\n\n        // Set in memory\n        this.hostname = hostname;\n\n    }\n\n    public async startSync() {\n        if (!this.isLoggedIn) {\n            throw Error(\"Not logged in\");\n        }\n        if (!this.database) {\n            await this.createDatabase();\n        }\n        if (this.syncing) {\n            return;\n        }\n        this.syncing = true;\n        while (this.syncing) {\n            try {\n                await this.sync();\n            } catch (e) {\n                console.error(e);\n                return;\n            }\n        }\n    }\n\n    public stopSync() {\n        this.syncing = false;\n    }\n\n    private isIndexInRange(index: number, ranges: number[][]): boolean {\n        for (const r of ranges) {\n            if (r[0] < index && index <= r[1]) {\n                return true\n            }\n        }\n        return false\n    }\n\n    private shiftRight(listKey: string, ranges: number[][], hi: number, low: number) {\n        //     l   h\n        // 0,1,2,3,4 <- before\n        // 0,1,2,2,3 <- after, hi is deleted and low is duplicated\n        for (let i = hi - 1; i > low - 1; i--) {\n            if (this.isIndexInRange(i, ranges)) {\n                const roomObj = [...this.rooms].find(room => room.windowPos[listKey] === i + 1);\n                if (roomObj) {\n                    roomObj.windowPos[listKey] = (i);\n                }\n            }\n        }\n    }\n\n    private shiftLeft(listKey: string, ranges: number[][], hi: number, low: number) {\n        //     l   h\n        // 0,1,2,3,4 <- before\n        // 0,1,3,4,4 <- after, low is deleted and hi is duplicated\n        for (let i = low + 1; i < hi + 1; i++) {\n            if (this.isIndexInRange(i, ranges)) {\n                const roomObj = [...this.rooms].find(room => room.windowPos[listKey] === i - 1);\n                if (roomObj) {\n                    roomObj.windowPos[listKey] = (i);\n                }\n            }\n        }\n\n    }\n\n    private removeEntry(listKey: string, ranges: number[][], index: number) {\n        // work out the max index\n        let max = -1;\n        const indexes = [...this.rooms].map(room => room.windowPos[listKey]);\n        for (const n in indexes) {\n            if (Number(n) > max) {\n                max = Number(n);\n            }\n        }\n        if (max < 0 || index > max) {\n            return;\n        }\n        // Everything higher than the gap needs to be shifted left.\n        this.shiftLeft(listKey, ranges, max, index);\n    }\n\n    private addEntry(listKey: string, ranges: number[][], index: number): void {\n        // work out the max index\n        let max = -1;\n        const indexes = [...this.rooms].map(room => room.windowPos[listKey]);\n        for (const n in indexes) {\n            if (Number(n) > max) {\n                max = Number(n);\n            }\n        }\n        if (max < 0 || index > max) {\n            return;\n        }\n        // Everything higher than the gap needs to be shifted right, +1 so we don't delete the highest element\n        this.shiftRight(listKey, ranges, max + 1, index);\n    }\n\n    private async sync() {\n        if (!this.isLoggedIn) {\n            throw Error(\"Not logged in\");\n        }\n        if (!this.slidingSyncHostname) {\n            throw Error(\"Hostname must be set first\");\n        }\n\n        // This is the initial sync case for each list\n        let lists_ranges: {\n            \"overview\": number[][];\n            [key: string]: number[][];\n        } = {\n            \"overview\": [[0, 10]],\n            // Needed for calcs\n            \"spaces\": [[0, Number.MAX_SAFE_INTEGER]]\n        };\n        let timeline_limit = 1;\n        if (!this.initialSync) {\n            for (const list in lists_ranges) {\n                // Set higher timeline limit for subsequent syncs\n                timeline_limit = 10;\n                // Calculate overlap between this.roomsInView and this.roomToRoomID and then\n                // calculate the ranges for each list\n                const rawRangeInView = [...this.rooms]\n                    .filter(room => this.roomsInView.includes(room.roomID))\n                    .map(room => room.windowPos[list])\n                    .sort();\n\n                // Increment range by 1 to make sure we always get a little more than we need\n                // [1,2,3,4,7,8,9,10,11] -> [2,3,4,5,8,9,10,11,12]\n                rawRangeInView.push(rawRangeInView[rawRangeInView.length - 1] + 1);\n\n                // Turn an input like [1,2,3,4,7,8,9,10,11] to [[1,4], [7,11]]\n                const rangesInView = rawRangeInView.reduce((acc, cur, i, arr) => {\n                    if (i === 0) {\n                        // [1,2,3,4] -> [[1,1]]\n                        acc.push([cur, cur]);\n                        return acc;\n                    }\n                    // Cur = 2, arr = [1,2,3,4], arr[i - 1] + 1 = 2 then\n                    if (cur === arr[i - 1] + 1) {\n                        // [1,2,3,4,7] -> [[1,2]]\n                        acc[acc.length - 1][1] = cur;\n                        return acc;\n                    }\n                    // Else [1,2,3,4,7] -> [[1,2], [7,7]]\n                    acc.push([cur, cur]);\n                    return acc;\n                }, [] as [number, number][]);\n\n                lists_ranges[list] = rangesInView;\n            }\n        }\n\n\n        if (this.lastRanges && Object.entries(lists_ranges).toString() !== Object.entries(this.lastRanges).toString()) {\n            console.log(\"Ranges changed, resetting sync txn_id\")\n            this.lastRanges = lists_ranges;\n            this.lastTxnID = Date.now().toString();\n        }\n\n        if (!this.lastRanges) {\n            this.lastRanges = lists_ranges;\n            this.lastTxnID = Date.now().toString();\n        }\n\n\n        let url = `${this.slidingSyncHostname}/_matrix/client/unstable/org.matrix.msc3575/sync?timeout=30000`;\n        if (this.syncPos) {\n            url = `${this.slidingSyncHostname}/_matrix/client/unstable/org.matrix.msc3575/sync?timeout=30000&pos=${this.syncPos}`\n        }\n\n        const resp = await fetch(url, {\n            method: \"POST\",\n            headers: {\n                \"Authorization\": `Bearer ${this.access_token}`\n            },\n            body: JSON.stringify({\n                // allows clients to know what request params reached the server,\n                // functionally similar to txn IDs on /send for events.\n                // TODO: check resp\n                txn_id: this.lastTxnID,\n\n                // a delta token to remember information between sessions.\n                // See \"Bandwidth optimisations for persistent clients\" for more information.\n                // TODO: This isnt implemented anywhere yet\n                //delta_token: \"opaque-server-provided-string\",\n\n                // Sliding Window API\n                lists: {\n                    // TODO: We need a list that fetches all spaces\n                    \"spaces\": {\n                        slow_get_all_rooms: true,\n                        sort: [\"by_name\"],\n                        required_state: [\n                            // needed to build sections\n                            [\"m.space.child\", \"*\"],\n                            [\"m.space.parent\", \"*\"],\n                            [\"m.room.create\", \"\"],\n                            // Room Avatar\n                            [\"m.room.avatar\", \"*\"],\n                        ],\n                        timeline_limit: timeline_limit,\n                        filters: {\n                            room_types: [\"m.space\"]\n                        }\n                    },\n                    \"overview\": {\n                        ranges: this.lastRanges[\"overview\"],\n                        sort: [\"by_notification_level\", \"by_recency\", \"by_name\"],\n                        required_state: [\n                            // needed to build sections\n                            [\"m.space.child\", \"*\"],\n                            [\"m.space.parent\", \"*\"],\n                            [\"m.room.create\", \"\"],\n                            // Room Avatar\n                            [\"m.room.avatar\", \"*\"],\n                        ],\n                        timeline_limit: timeline_limit,\n                        filters: {}\n                    },\n                },\n                bump_event_types: [\"m.room.message\", \"m.room.encrypted\"],\n\n                // Room Subscriptions API\n                //room_subscriptions: {},\n                //unsubscribe_rooms: []\n            })\n        });\n        if (!resp.ok) {\n            if (resp.status === 400) {\n                if ((await resp.json()).errcode === \"M_UNKNOWN_POS\") {\n                    this.syncPos = undefined;\n                    const syncInfoTX = this.database?.transaction('syncInfo', 'readwrite');\n                    await syncInfoTX?.store.put({\n                        userId: this.mxid!,\n                        syncPos: this.syncPos,\n                        initialSync: this.initialSync,\n                        lastRanges: this.lastRanges,\n                        lastTxnID: this.lastTxnID,\n                    });\n                    await syncInfoTX?.done;\n                }\n            }\n            console.error(resp);\n            throw Error(\"Error syncing. See console for error.\");\n        }\n        const json = await resp.json() as ISlidingSyncResp;\n        this.syncPos = json.pos;\n\n\n        const syncInfoTX = this.database?.transaction('syncInfo', 'readwrite');\n        await syncInfoTX?.store.put({\n            userId: this.mxid!,\n            syncPos: this.syncPos,\n            initialSync: this.initialSync,\n            lastRanges: this.lastRanges,\n            lastTxnID: this.lastTxnID,\n        });\n        await syncInfoTX?.done;\n\n        let gapIndex = -1;\n        for (const listKey in json.lists) {\n            const list = json.lists[listKey];\n            if (list.ops) {\n                for (const op of list.ops) {\n                    if (isSyncOp(op)) {\n                        const tx = this.database?.transaction('rooms', 'readwrite');\n                        for (let i = op.range[0]; i <= op.range[1]; i++) {\n                            const roomID = op.room_ids[i - op.range[0]];\n                            if (!roomID) {\n                                break; // we are at the end of list\n                            }\n\n                            // Check if we already know this room and skip if we do. This is needed since we have 2 lists.\n                            // The db would already do this but the obj list doesn't (even though its a Set. Thats a mystery yet to solve)\n                            const roomObj = [...this.rooms].find(room => room.roomID === roomID);\n                            if (roomObj) {\n                                roomObj.windowPos[listKey] = i;\n                                continue;\n                            }\n\n                            // We start to remember the Room now.\n                            const newRoom = new Room(roomID, this.hostname!);\n                            newRoom.setName(roomID);\n                            newRoom.windowPos[listKey] = i;\n\n                            this.rooms.add(newRoom);\n                            await tx?.store.put({\n                                windowPos: newRoom.windowPos,\n                                roomID: newRoom.roomID,\n                                name: newRoom.getName(),\n                                notification_count: newRoom.getNotificationCount(),\n                                highlight_count: newRoom.getNotificationHighlightCount(),\n                                joined_count: newRoom.getJoinedCount(),\n                                invited_count: newRoom.getInvitedCount(),\n                                avatarUrl: newRoom.getAvatarURL(),\n                                isSpace: newRoom.isSpace(),\n                            });\n                        }\n                        await tx?.done;\n                    } else if (isInsertOp(op)) {\n                        console.log(\"Got INSERT OP\", op);\n                        const roomObj = [...this.rooms].find(room => room.windowPos[listKey] === op.index);\n                        if (roomObj) {\n                            if (gapIndex < 0) {\n                                // we haven't been told where to shift from, so make way for a new room entry.\n                                this.addEntry(listKey, this.lastRanges[listKey], op.index);\n                            } else if (gapIndex > op.index) {\n                                // the gap is further down the list, shift every element to the right\n                                // starting at the gap so we can just shift each element in turn:\n                                // [A,B,C,_] gapIndex=3, op.index=0\n                                // [A,B,C,C] i=3\n                                // [A,B,B,C] i=2\n                                // [A,A,B,C] i=1\n                                // Terminate. We'll assign into op.index next.\n                                this.shiftRight(listKey, this.lastRanges[listKey], gapIndex, op.index);\n                            } else if (gapIndex < op.index) {\n                                // the gap is further up the list, shift every element to the left\n                                // starting at the gap so we can just shift each element in turn\n                                this.shiftLeft(listKey, this.lastRanges[listKey], op.index, gapIndex);\n                            }\n                        }\n                        gapIndex = -1;\n                        const tx = this.database?.transaction('rooms', 'readwrite');\n                        // We start to remember the Room now.\n                        const foundRoom = [...this.rooms].find(room => room.roomID === op.room_id);\n                        if (foundRoom) {\n                            foundRoom.windowPos[listKey] = op.index;\n                            await tx?.store.put({\n                                windowPos: foundRoom.windowPos,\n                                roomID: foundRoom.roomID,\n                                name: foundRoom.getName(),\n                                notification_count: foundRoom.getNotificationCount(),\n                                highlight_count: foundRoom.getNotificationHighlightCount(),\n                                joined_count: foundRoom.getJoinedCount(),\n                                invited_count: foundRoom.getInvitedCount(),\n                                avatarUrl: foundRoom.getAvatarURL(),\n                                isSpace: foundRoom.isSpace(),\n                            });\n                        } else {\n                            const newRoom = new Room(op.room_id, this.hostname!);\n                            newRoom.setName(op.room_id);\n                            newRoom.windowPos[listKey] = op.index;\n                            this.rooms.add(newRoom);\n                            await tx?.store.put({\n                                windowPos: newRoom.windowPos,\n                                roomID: newRoom.roomID,\n                                name: newRoom.getName(),\n                                notification_count: newRoom.getNotificationCount(),\n                                highlight_count: newRoom.getNotificationHighlightCount(),\n                                joined_count: newRoom.getJoinedCount(),\n                                invited_count: newRoom.getInvitedCount(),\n                                avatarUrl: newRoom.getAvatarURL(),\n                                isSpace: newRoom.isSpace(),\n                            });\n                        }\n\n                        const roomIDs2 = [...this.rooms].map(room => room.roomID);\n                        // Check if we generated any duplicates and log them.\n                        const duplicates = roomIDs2.filter((item, index) => roomIDs2.indexOf(item) != index);\n                        if (duplicates.length > 0) {\n                            console.error(\"Duplicates found\", duplicates);\n                        }\n                        await tx?.done;\n                    } else if (isDeleteOp(op)) {\n                        console.log(\"Got DELETE OP\", op);\n\n                        const roomObj = [...this.rooms].find(room => room.windowPos[listKey] === op.index);\n                        if (roomObj) {\n                            const tx = this.database?.transaction('rooms', 'readwrite');\n                            await tx?.store.delete(roomObj.roomID);\n                            await tx?.done;\n                            this.rooms.delete(roomObj)\n                        }\n                        if (gapIndex !== -1) {\n                            // we already have a DELETE operation to process, so process it.\n                            this.removeEntry(listKey, this.lastRanges[listKey], gapIndex);\n                        }\n                        gapIndex = op.index;\n                    } else if (isInvalidateOp(op)) {\n                        const tx = this.database?.transaction('rooms', 'readwrite');\n                        for (let i = op.range[0]; i <= op.range[1]; i++) {\n                            // We shall first forget about these and \"startover\"\n                            const roomObj = [...this.rooms].find(room => room.windowPos[listKey] === i);\n                            if (roomObj) {\n                                await tx?.store.delete(roomObj.roomID);\n                                this.rooms.delete(roomObj)\n                            }\n                        }\n                        await tx?.done;\n                    }\n                }\n                if (gapIndex !== -1) {\n                    // we already have a DELETE operation to process, so process it\n                    // Everything higher than the gap needs to be shifted left.\n                    this.removeEntry(listKey, this.lastRanges[listKey], gapIndex);\n                }\n            }\n        }\n        const tx = this.database?.transaction('rooms', 'readwrite');\n        for (const roomID in json.rooms) {\n            const room = json.rooms[roomID];\n            const name = room.name;\n            const notification_count = room.notification_count;\n            const notification_highlight_count = room.highlight_count;\n            const joined_count = room.joined_count;\n            const invited_count = room.invited_count;\n            const events = room.timeline;\n            const required_state = room.required_state;\n\n            const roomObj = [...this.rooms].find(room => room.roomID === roomID);\n            if (!roomObj) {\n                // TODO: Warn but create missing room instead of failing on it\n                console.error(\"Could not find roomObj for roomID\", roomID);\n                continue;\n            }\n\n            if (name) {\n                roomObj.setName(name);\n            }\n            roomObj.setNotificationCount(notification_count);\n            roomObj.setNotificationHighlightCount(notification_highlight_count);\n            roomObj.setJoinedCount(joined_count);\n            roomObj.setInvitedCount(invited_count);\n            if (events) {\n                roomObj.addEvents(events);\n            }\n            if (required_state) {\n                roomObj.addStateEvents(required_state);\n            }\n\n            // Write to database\n            await tx?.store.put({\n                windowPos: roomObj.windowPos,\n                roomID: roomObj.roomID,\n                name: roomObj.getName(),\n                notification_count: roomObj.getNotificationCount(),\n                highlight_count: roomObj.getNotificationHighlightCount(),\n                joined_count: roomObj.getJoinedCount(),\n                invited_count: roomObj.getInvitedCount(),\n                events: events,\n                stateEvents: required_state,\n                avatarUrl: roomObj.getAvatarURL(),\n                isSpace: roomObj.isSpace(),\n            });\n        }\n        await tx?.done\n        if (json.rooms && Object.keys(json.rooms).length > 0) {\n            this.emit(\"rooms\", this.rooms);\n        }\n    }\n\n    /**\n     * addInViewRoom\n     * \n     * Tells the sync that a room with a certain roomID is inView.\n     */\n    public addInViewRoom(roomID: string) {\n        this.roomsInView.push(roomID);\n    }\n\n    /**\n     * removeInViewRoom\n     * \n     * Tells the sync that a room isn't in the room anymore\n     */\n    public removeInViewRoom(roomID: string) {\n        this.roomsInView = this.roomsInView.filter(room => room !== roomID);\n    }\n\n    public getRooms(): Set<Room> {\n        return this.rooms;\n    }\n\n    private getSpaces(): Room[] {\n        return [...this.rooms].filter(room => room.isSpace()).sort((a: Room, b: Room) => {\n            if (a.getName() < b.getName()) {\n                return -1;\n            }\n            if (a.getName() > b.getName()) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n\n    public getSpacesWithRooms(): Set<{\n        spaceRoom: Room, children: Set<Room>\n    }> {\n        const spaces = this.getSpaces();\n        const result: Set<{\n            spaceRoom: Room, children: Set<Room>\n        }> = new Set();\n        // Find children of spaces\n        for (const space of spaces) {\n            const childrenIDs = space.getSpaceChildrenIDs();\n\n            const children = new Set([...this.getRooms()].filter(room => childrenIDs.includes(room.roomID)));\n\n            result.add({\n                spaceRoom: space,\n                children: children,\n            });\n        }\n        // Find spaces of parents\n        // Check parents of each room and if we have a parent make sure to add it to the result unless already added\n        for (const room of this.getRooms()) {\n            const parents = room.getSpaceParentIDs();\n            for (const parent of parents) {\n                const parentObj = [...this.getRooms()].find(room => room.roomID === parent.roomID);\n                if (!parentObj) {\n                    continue;\n                }\n                const alreadyAddedSpace = [...result].find(space => space.spaceRoom.roomID === parentObj.roomID);\n                if (alreadyAddedSpace) {\n                    // Check if room in children\n                    if (![...alreadyAddedSpace.children].find(child => child.roomID === room.roomID)) {\n                        alreadyAddedSpace.children.add(room);\n                    }\n                    continue;\n                }\n                // If space not added yet, add it\n                result.add({\n                    spaceRoom: parentObj,\n                    children: new Set([room]),\n                });\n            }\n        }\n\n        return result;\n    }\n\n    private async getLoginFlows(): Promise<ILoginFlows> {\n        if (!this.hostname) {\n            throw Error(\"Hostname must be set first\");\n        }\n        const resp = await fetch(`${this.hostname}/_matrix/client/v3/login`);\n        if (!resp.ok) {\n            console.error(resp);\n            throw Error(\"Error requesting login flows. See console for error.\");\n        }\n        const json = await resp.json() as ILoginFlows;\n        return json;\n    }\n\n    private async getWellKnown(): Promise<IWellKnown> {\n        if (!this.hostname) {\n            throw Error(\"Hostname must be set first\");\n        }\n        const resp = await fetch(`${this.hostname}/.well-known/matrix/client`);\n        if (!resp.ok) {\n            console.error(resp);\n            throw Error(\"Error requesting login flows. See console for error.\");\n        }\n        const json = await resp.json() as IWellKnown;\n        return json;\n    }\n\n    public async passwordLogin(username: string, password: string, triesLeft = 5) {\n        if (!this.database) {\n            await this.createDatabase();\n        }\n        if (!username) {\n            throw Error(\"Username must be set\");\n        }\n        if (!password) {\n            throw Error(\"Password must be set\");\n        }\n        this.mxid = username;\n        await this.setHostname(`https://${username.split(':')[1]}`);\n\n        try {\n            const well_known = await this.getWellKnown();\n            if (well_known[\"m.homeserver\"]?.base_url) {\n                await this.setHostname(well_known[\"m.homeserver\"].base_url);\n            }\n            if (well_known[\"org.matrix.msc3575.proxy\"]?.url) {\n                // Write to database\n                const tx = this.database?.transaction('loginInfo', 'readwrite');\n                await tx?.store.put({\n                    userId: this.mxid!,\n                    hostname: this.hostname,\n                    slidingSyncHostname: well_known[\"org.matrix.msc3575.proxy\"].url,\n                    access_token: this.access_token,\n                    device_id: this.device_id,\n                });\n                await tx?.done\n\n                // Set the sliding sync proxy\n                this.slidingSyncHostname = well_known[\"org.matrix.msc3575.proxy\"].url;\n            } else {\n                throw Error(\"No sliding sync proxy found\");\n            }\n        } catch (e: any) {\n            console.warn(`No well-known found for ${this.hostname}:\\n${e}`);\n        }\n\n        const loginFlows = await this.getLoginFlows();\n        if ((loginFlows.flows.filter((flow) => flow.type === 'm.login.password')?.length || 0) == 0) {\n            throw Error(\"Password login is not supported by this homeserver\");\n        }\n\n        const resp = await fetch(`${this.hostname}/_matrix/client/r0/login`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                type: \"m.login.password\",\n                identifier: {\n                    type: 'm.id.user',\n                    user: username,\n                },\n                user: username,\n                password: password\n            })\n        });\n        if (!resp.ok) {\n            console.error(resp);\n            throw Error(\"Error logging in. See console for error.\");\n        }\n        const json = await resp.json();\n        if (isErrorResp(json)) {\n            throw Error(`Error logging in: ${json.errcode}: ${json.error}`);\n        }\n        if (isRateLimitError(json)) {\n            console.error(`Rate limited. Retrying in ${json.retry_after_ms}ms. ${triesLeft} tries left.`);\n            await this.passwordLogin(username, password, triesLeft - 1);\n        }\n        if (isLoginResponse(json)) {\n            // Write to database\n            const tx = this.database?.transaction('loginInfo', 'readwrite');\n            await tx?.store.put({\n                userId: json.user_id!,\n                hostname: this.hostname,\n                slidingSyncHostname: this.slidingSyncHostname,\n                access_token: json.access_token,\n                device_id: json.device_id,\n            });\n            await tx?.done\n            this.access_token = json.access_token;\n            this.device_id = json.device_id;\n            this.mxid = json.user_id;\n        }\n    }\n\n    public async fetchProfileInfo(userId: string): Promise<IProfileInfo> {\n        if (this.profileInfo) {\n            return this.profileInfo;\n        }\n        if (!this.hostname) {\n            throw Error(\"Hostname must be set first\");\n        }\n        if (!this.database) {\n            await this.createDatabase();\n        }\n        if (!this.access_token) {\n            throw Error(\"Access token must be set first\");\n        }\n        const resp = await fetch(`${this.hostname}/_matrix/client/r0/profile/${userId}`, {\n            headers: {\n                \"Authorization\": `Bearer ${this.access_token}`\n            }\n        });\n        if (!resp.ok) {\n            if (resp.status === 404 || resp.status === 403) {\n                return {} as IProfileInfo;\n            }\n            console.error(resp);\n            throw Error(\"Error fetching profile info. See console for error.\");\n        }\n        const json = await resp.json() as IProfileInfo;\n        json.avatar_url = json.avatar_url?.replace(\"mxc://\", `${this.hostname}/_matrix/media/r0/download/`);\n        this.profileInfo = json;\n        const tx = this.database?.transaction('loginInfo', 'readwrite');\n        await tx?.store.put({\n            userId: this.mxid!,\n            device_id: this.device_id!,\n            hostname: this.hostname,\n            slidingSyncHostname: this.slidingSyncHostname,\n            access_token: this.access_token,\n            displayName: json.displayname,\n            avatarUrl: json.avatar_url,\n        });\n        await tx?.done\n\n        return json;\n    }\n}\n\nfunction isRateLimitError(arg: any): arg is IRateLimitError {\n    return arg.retry_after_ms !== undefined;\n}\n\nfunction isLoginResponse(arg: any): arg is ILoginResponse {\n    return arg.access_token !== undefined;\n}\n\nfunction isErrorResp(arg: any): arg is IErrorResp {\n    return arg.errcode !== undefined;\n}\n\nexport const defaultMatrixClient: MatrixClient = await MatrixClient.Instance();\nexport const MatrixContext = createContext<MatrixClient>(defaultMatrixClient);\n\n// List of rooms\nexport function useRooms() {\n    const client = useContext(MatrixContext);\n    const [rooms, setRooms] = useState<Set<Room>>(client.getRooms());\n\n    useEffect(() => {\n        // Listen for room updates\n        const listenForRooms = (rooms: Set<Room>) => {\n            setRooms(rooms);\n        };\n        client.on(\"rooms\", listenForRooms);\n        // This is a no-op if there is already a sync\n        client.startSync();\n        return () => {\n            client.removeListener(\"rooms\", listenForRooms);\n        }\n    }, [])\n    return rooms;\n}\n\nexport function useSpaces() {\n    const client = useContext(MatrixContext);\n    const [spacesWithRooms, setSpacesWithRooms] = useState<Set<{\n        spaceRoom: Room, children: Set<Room>\n    }>>(client.getSpacesWithRooms());\n\n    useEffect(() => {\n        // Listen for room updates\n        const listenForRooms = (_rooms: Set<Room>) => {\n            setSpacesWithRooms(client.getSpacesWithRooms());\n        };\n        client.on(\"rooms\", listenForRooms);\n        // This is a no-op if there is already a sync\n        client.startSync();\n        return () => {\n            client.removeListener(\"rooms\", listenForRooms);\n        }\n    }, [])\n    return spacesWithRooms;\n}\n\n\nexport function useProfile() {\n    const client = useContext(MatrixContext);\n    const [profile, setProfile] = useState<IProfileInfo>({\n        displayname: client.mxid || \"Unknown\",\n    });\n\n    useEffect(() => {\n        client.fetchProfileInfo(client.mxid!).then((profile) => {\n            if (!profile.displayname) {\n                profile.displayname = client.mxid || \"Unknown\";\n            }\n            setProfile(profile);\n        })\n    }, [])\n    return profile;\n}"],"names":["isSyncOp","op","isInsertOp","isInvalidateOp","isDeleteOp","isRoomCreateEvent","event","isRoomAvatarEvent","isSpaceChildEvent","isSpaceParentEvent","Room","roomID","hostname","events","state","avatarURL","rawAvatarURL","isSpace","name","count","children","parents","R","ReflectApply","target","receiver","args","ReflectOwnKeys","ProcessEmitWarning","warning","NumberIsNaN","value","EventEmitter","eventsModule","once","defaultMaxListeners","checkListener","listener","arg","n","_getMaxListeners","that","type","i","doError","er","err","handler","len","listeners","arrayClone","_addListener","prepend","m","existing","w","onceWrapper","_onceWrap","wrapped","list","position","originalListener","spliceOne","keys","key","_listeners","unwrap","evlistener","unwrapListeners","emitter","listenerCount","arr","copy","index","ret","resolve","reject","errorListener","resolver","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","wrapListener","instanceOfAny","object","constructors","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","getCursorAdvanceMethods","cursorRequestMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","promisifyRequest","request","promise","unlisten","success","error","wrap","cacheDonePromiseForTransaction","tx","done","complete","idbProxyTraps","prop","replaceTraps","callback","wrapFunction","func","storeNames","transformCachableValue","newValue","openDB","version","blocked","upgrade","blocking","terminated","openPromise","db","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","method","storeName","oldTraps","MatrixClient","instance","loginInfo","syncTx","syncInfo","roomTx","rooms","room","roomObj","e","ranges","r","listKey","hi","low","max","indexes","lists_ranges","timeline_limit","rawRangeInView","rangesInView","acc","cur","url","resp","syncInfoTX","json","gapIndex","newRoom","foundRoom","roomIDs2","duplicates","item","notification_count","notification_highlight_count","joined_count","invited_count","required_state","a","b","spaces","result","space","childrenIDs","parent","parentObj","alreadyAddedSpace","child","username","password","triesLeft","well_known","flow","isErrorResp","isRateLimitError","isLoginResponse","userId","defaultMatrixClient","MatrixContext","createContext","useRooms","client","useContext","setRooms","useState","useEffect","listenForRooms","useSpaces","spacesWithRooms","setSpacesWithRooms","_rooms","useProfile","profile","setProfile"],"mappings":"wCA+LO,SAASA,EAASC,EAAwB,CAC7C,OAAOA,EAAG,KAAO,MACrB,CAEO,SAASC,EAAWD,EAA0B,CACjD,OAAOA,EAAG,KAAO,QACrB,CAEO,SAASE,EAAeF,EAA8B,CACzD,OAAOA,EAAG,KAAO,YACrB,CAEO,SAASG,EAAWH,EAA0B,CACjD,OAAOA,EAAG,KAAO,QACrB,CA4EO,SAASI,GAAkBC,EAA8C,CAC5E,OAAOA,EAAM,OAAS,eAC1B,CAyBO,SAASC,GAAkBD,EAA8C,CAC5E,OAAOA,EAAM,OAAS,eAC1B,CAUO,SAASE,GAAkBF,EAA8C,CAC5E,OAAOA,EAAM,OAAS,eAC1B,CASO,SAASG,GAAmBH,EAA+C,CAC9E,OAAOA,EAAM,OAAS,gBAC1B,CC3UO,MAAMI,CAAK,CAed,YAAmBC,EAAwBC,EAAkB,CAA1C,KAAA,OAAAD,EAAwB,KAAA,SAAAC,CAAoB,CAdvD,OAAuB,CAAA,EACvB,YAAiC,CAAA,EACjC,KAEA,mBAA6B,EAC7B,6BAAuC,EACvC,aAAuB,EACvB,cAAwB,EAEzB,UAEH,CAAA,EAKG,UAAUC,EAAsB,CAC9B,KAAA,OAAO,KAAK,GAAGA,CAAM,CAC9B,CAEO,eAAeC,EAA0B,CACvC,KAAA,YAAY,KAAK,GAAGA,CAAK,CAClC,CAEO,cAAmC,CACtC,IAAIC,EACC,YAAA,YAAY,QAAST,GAAU,CAC5B,GAAAC,GAAkBD,CAAK,EAAG,CACpB,MAAAU,EAAeV,EAAM,QAAQ,IAC/BU,GAAc,WAAW,QAAQ,IACjCD,EAAY,GAAG,KAAK,sCAAsCC,EAAa,UAAU,CAAC,KAE1F,CACH,EACMD,CACX,CAEO,SAAmB,CACtB,IAAIE,EAAmB,GAClB,YAAA,YAAY,QAASX,GAAU,CAC5BD,GAAkBC,CAAK,IACbW,EAAAX,EAAM,QAAQ,OAAS,UACrC,CACH,EACMW,CACX,CAEO,QAAQC,EAAc,CACzB,KAAK,KAAOA,CAChB,CAEO,SAAkB,CACjB,OAAC,KAAK,KAGH,KAAK,KAFD,KAAK,MAGpB,CAEO,qBAAqBC,EAAe,CACvC,KAAK,mBAAqBA,CAC9B,CAEO,sBAA+B,CAClC,OAAO,KAAK,kBAChB,CAEO,8BAA8BA,EAAe,CAChD,KAAK,6BAA+BA,CACxC,CAEO,+BAAwC,CAC3C,OAAO,KAAK,4BAChB,CAEO,eAAeA,EAAe,CACjC,KAAK,aAAeA,CACxB,CAEO,gBAAyB,CAC5B,OAAO,KAAK,YAChB,CAEO,gBAAgBA,EAAe,CAClC,KAAK,cAAgBA,CACzB,CAEO,iBAA0B,CAC7B,OAAO,KAAK,aAChB,CAEO,qBAAgC,CACnC,MAAMC,EAAqB,CAAA,EACtB,YAAA,YAAY,QAASd,GAAU,CAC5BE,GAAkBF,CAAK,GACdc,EAAA,KAAKd,EAAM,SAAS,CACjC,CACH,EACMc,CACX,CAEO,mBAA8D,CACjE,MAAMC,EAAoD,CAAA,EACrD,YAAA,YAAY,QAASf,GAAU,CAC5BG,GAAmBH,CAAK,GAChBe,EAAA,KAAK,CAAE,OAAQf,EAAM,UAAW,UAAWA,EAAM,QAAQ,WAAa,EAAO,CAAA,CACzF,CACH,EACMe,CACX,CAEO,MAAgB,CAEZ,MAAA,EACX,CAEO,UAAoB,CAEhB,MAAA,EACX,CACJ,2DCnGIC,EAAI,OAAO,SAAY,SAAW,QAAU,KAC5CC,EAAeD,GAAK,OAAOA,EAAE,OAAU,WACvCA,EAAE,MACF,SAAsBE,EAAQC,EAAUC,EAAM,CAC9C,OAAO,SAAS,UAAU,MAAM,KAAKF,EAAQC,EAAUC,CAAI,CAC5D,EAECC,EACAL,GAAK,OAAOA,EAAE,SAAY,WAC5BK,EAAiBL,EAAE,QACV,OAAO,sBAChBK,EAAiB,SAAwBH,EAAQ,CAC/C,OAAO,OAAO,oBAAoBA,CAAM,EACrC,OAAO,OAAO,sBAAsBA,CAAM,CAAC,CAClD,EAEEG,EAAiB,SAAwBH,EAAQ,CAC/C,OAAO,OAAO,oBAAoBA,CAAM,CAC5C,EAGA,SAASI,GAAmBC,EAAS,CAC/B,SAAW,QAAQ,MAAM,QAAQ,KAAKA,CAAO,CACnD,CAEA,IAAIC,EAAc,OAAO,OAAS,SAAqBC,EAAO,CAC5D,OAAOA,IAAUA,CACnB,EAEA,SAASC,GAAe,CACtBA,EAAa,KAAK,KAAK,IAAI,CAC7B,CACAC,GAAc,QAAGD,EACEnB,EAAA,KAAGqB,GAGtBF,EAAa,aAAeA,EAE5BA,EAAa,UAAU,QAAU,OACjCA,EAAa,UAAU,aAAe,EACtCA,EAAa,UAAU,cAAgB,OAIvC,IAAIG,EAAsB,GAE1B,SAASC,EAAcC,EAAU,CAC/B,GAAI,OAAOA,GAAa,WACtB,MAAM,IAAI,UAAU,mEAAqE,OAAOA,CAAQ,CAE5G,CAEA,OAAO,eAAeL,EAAc,sBAAuB,CACzD,WAAY,GACZ,IAAK,UAAW,CACd,OAAOG,CACR,EACD,IAAK,SAASG,EAAK,CACjB,GAAI,OAAOA,GAAQ,UAAYA,EAAM,GAAKR,EAAYQ,CAAG,EACvD,MAAM,IAAI,WAAW,kGAAoGA,EAAM,GAAG,EAEpIH,EAAsBG,CACvB,CACH,CAAC,EAEDN,EAAa,KAAO,UAAW,EAEzB,KAAK,UAAY,QACjB,KAAK,UAAY,OAAO,eAAe,IAAI,EAAE,WAC/C,KAAK,QAAU,OAAO,OAAO,IAAI,EACjC,KAAK,aAAe,GAGtB,KAAK,cAAgB,KAAK,eAAiB,MAC7C,EAIAA,EAAa,UAAU,gBAAkB,SAAyBO,EAAG,CACnE,GAAI,OAAOA,GAAM,UAAYA,EAAI,GAAKT,EAAYS,CAAC,EACjD,MAAM,IAAI,WAAW,gFAAkFA,EAAI,GAAG,EAEhH,YAAK,cAAgBA,EACd,IACT,EAEA,SAASC,EAAiBC,EAAM,CAC9B,OAAIA,EAAK,gBAAkB,OAClBT,EAAa,oBACfS,EAAK,aACd,CAEAT,EAAa,UAAU,gBAAkB,UAA2B,CAClE,OAAOQ,EAAiB,IAAI,CAC9B,EAEAR,EAAa,UAAU,KAAO,SAAcU,EAAM,CAEhD,QADIhB,EAAO,CAAA,EACFiB,EAAI,EAAGA,EAAI,UAAU,OAAQA,IAAKjB,EAAK,KAAK,UAAUiB,CAAC,CAAC,EACjE,IAAIC,EAAWF,IAAS,QAEpB7B,EAAS,KAAK,QAClB,GAAIA,IAAW,OACb+B,EAAWA,GAAW/B,EAAO,QAAU,eAChC,CAAC+B,EACR,MAAO,GAGT,GAAIA,EAAS,CACX,IAAIC,EAGJ,GAFInB,EAAK,OAAS,IAChBmB,EAAKnB,EAAK,CAAC,GACTmB,aAAc,MAGhB,MAAMA,EAGR,IAAIC,EAAM,IAAI,MAAM,oBAAsBD,EAAK,KAAOA,EAAG,QAAU,IAAM,GAAG,EAC5E,MAAAC,EAAI,QAAUD,EACRC,EAGR,IAAIC,EAAUlC,EAAO6B,CAAI,EAEzB,GAAIK,IAAY,OACd,MAAO,GAET,GAAI,OAAOA,GAAY,WACrBxB,EAAawB,EAAS,KAAMrB,CAAI,MAIhC,SAFIsB,EAAMD,EAAQ,OACdE,EAAYC,EAAWH,EAASC,CAAG,EAC9BL,EAAI,EAAGA,EAAIK,EAAK,EAAEL,EACzBpB,EAAa0B,EAAUN,CAAC,EAAG,KAAMjB,CAAI,EAGzC,MAAO,EACT,EAEA,SAASyB,EAAa3B,EAAQkB,EAAML,EAAUe,EAAS,CACrD,IAAIC,EACAxC,EACAyC,EAsBJ,GApBAlB,EAAcC,CAAQ,EAEtBxB,EAASW,EAAO,QACZX,IAAW,QACbA,EAASW,EAAO,QAAU,OAAO,OAAO,IAAI,EAC5CA,EAAO,aAAe,IAIlBX,EAAO,cAAgB,SACzBW,EAAO,KAAK,cAAekB,EACfL,EAAS,SAAWA,EAAS,SAAWA,CAAQ,EAI5DxB,EAASW,EAAO,SAElB8B,EAAWzC,EAAO6B,CAAI,GAGpBY,IAAa,OAEfA,EAAWzC,EAAO6B,CAAI,EAAIL,EAC1B,EAAEb,EAAO,qBAEL,OAAO8B,GAAa,WAEtBA,EAAWzC,EAAO6B,CAAI,EACpBU,EAAU,CAACf,EAAUiB,CAAQ,EAAI,CAACA,EAAUjB,CAAQ,EAE7Ce,EACTE,EAAS,QAAQjB,CAAQ,EAEzBiB,EAAS,KAAKjB,CAAQ,EAIxBgB,EAAIb,EAAiBhB,CAAM,EACvB6B,EAAI,GAAKC,EAAS,OAASD,GAAK,CAACC,EAAS,OAAQ,CACpDA,EAAS,OAAS,GAGlB,IAAIC,EAAI,IAAI,MAAM,+CACED,EAAS,OAAS,IAAM,OAAOZ,CAAI,EAAI,mEAEvB,EACpCa,EAAE,KAAO,8BACTA,EAAE,QAAU/B,EACZ+B,EAAE,KAAOb,EACTa,EAAE,MAAQD,EAAS,OACnB1B,GAAmB2B,CAAC,EAIxB,OAAO/B,CACT,CAEAQ,EAAa,UAAU,YAAc,SAAqBU,EAAML,EAAU,CACxE,OAAOc,EAAa,KAAMT,EAAML,EAAU,EAAK,CACjD,EAEAL,EAAa,UAAU,GAAKA,EAAa,UAAU,YAEnDA,EAAa,UAAU,gBACnB,SAAyBU,EAAML,EAAU,CACvC,OAAOc,EAAa,KAAMT,EAAML,EAAU,EAAI,CACpD,EAEA,SAASmB,IAAc,CACrB,GAAI,CAAC,KAAK,MAGR,OAFA,KAAK,OAAO,eAAe,KAAK,KAAM,KAAK,MAAM,EACjD,KAAK,MAAQ,GACT,UAAU,SAAW,EAChB,KAAK,SAAS,KAAK,KAAK,MAAM,EAChC,KAAK,SAAS,MAAM,KAAK,OAAQ,SAAS,CAErD,CAEA,SAASC,EAAUjC,EAAQkB,EAAML,EAAU,CACzC,IAAIvB,EAAQ,CAAE,MAAO,GAAO,OAAQ,OAAW,OAAQU,EAAQ,KAAMkB,EAAM,SAAUL,CAAQ,EACzFqB,EAAUF,GAAY,KAAK1C,CAAK,EACpC,OAAA4C,EAAQ,SAAWrB,EACnBvB,EAAM,OAAS4C,EACRA,CACT,CAEA1B,EAAa,UAAU,KAAO,SAAcU,EAAML,EAAU,CAC1D,OAAAD,EAAcC,CAAQ,EACtB,KAAK,GAAGK,EAAMe,EAAU,KAAMf,EAAML,CAAQ,CAAC,EACtC,IACT,EAEAL,EAAa,UAAU,oBACnB,SAA6BU,EAAML,EAAU,CAC3C,OAAAD,EAAcC,CAAQ,EACtB,KAAK,gBAAgBK,EAAMe,EAAU,KAAMf,EAAML,CAAQ,CAAC,EACnD,IACb,EAGAL,EAAa,UAAU,eACnB,SAAwBU,EAAML,EAAU,CACtC,IAAIsB,EAAM9C,EAAQ+C,EAAU,EAAGC,EAK/B,GAHAzB,EAAcC,CAAQ,EAEtBxB,EAAS,KAAK,QACVA,IAAW,OACb,OAAO,KAGT,GADA8C,EAAO9C,EAAO6B,CAAI,EACdiB,IAAS,OACX,OAAO,KAET,GAAIA,IAAStB,GAAYsB,EAAK,WAAatB,EACrC,EAAE,KAAK,eAAiB,EAC1B,KAAK,QAAU,OAAO,OAAO,IAAI,GAEjC,OAAOxB,EAAO6B,CAAI,EACd7B,EAAO,gBACT,KAAK,KAAK,iBAAkB6B,EAAMiB,EAAK,UAAYtB,CAAQ,WAEtD,OAAOsB,GAAS,WAAY,CAGrC,IAFAC,EAAW,GAEN,EAAID,EAAK,OAAS,EAAG,GAAK,EAAG,IAChC,GAAIA,EAAK,CAAC,IAAMtB,GAAYsB,EAAK,CAAC,EAAE,WAAatB,EAAU,CACzDwB,EAAmBF,EAAK,CAAC,EAAE,SAC3BC,EAAW,EACX,MAIJ,GAAIA,EAAW,EACb,OAAO,KAELA,IAAa,EACfD,EAAK,MAAK,EAEVG,GAAUH,EAAMC,CAAQ,EAGtBD,EAAK,SAAW,IAClB9C,EAAO6B,CAAI,EAAIiB,EAAK,CAAC,GAEnB9C,EAAO,iBAAmB,QAC5B,KAAK,KAAK,iBAAkB6B,EAAMmB,GAAoBxB,CAAQ,EAGlE,OAAO,IACb,EAEAL,EAAa,UAAU,IAAMA,EAAa,UAAU,eAEpDA,EAAa,UAAU,mBACnB,SAA4BU,EAAM,CAChC,IAAIO,EAAWpC,EAAQ8B,EAGvB,GADA9B,EAAS,KAAK,QACVA,IAAW,OACb,OAAO,KAGT,GAAIA,EAAO,iBAAmB,OAC5B,OAAI,UAAU,SAAW,GACvB,KAAK,QAAU,OAAO,OAAO,IAAI,EACjC,KAAK,aAAe,GACXA,EAAO6B,CAAI,IAAM,SACtB,EAAE,KAAK,eAAiB,EAC1B,KAAK,QAAU,OAAO,OAAO,IAAI,EAEjC,OAAO7B,EAAO6B,CAAI,GAEf,KAIT,GAAI,UAAU,SAAW,EAAG,CAC1B,IAAIqB,EAAO,OAAO,KAAKlD,CAAM,EACzBmD,EACJ,IAAKrB,EAAI,EAAGA,EAAIoB,EAAK,OAAQ,EAAEpB,EAC7BqB,EAAMD,EAAKpB,CAAC,EACRqB,IAAQ,kBACZ,KAAK,mBAAmBA,CAAG,EAE7B,YAAK,mBAAmB,gBAAgB,EACxC,KAAK,QAAU,OAAO,OAAO,IAAI,EACjC,KAAK,aAAe,EACb,KAKT,GAFAf,EAAYpC,EAAO6B,CAAI,EAEnB,OAAOO,GAAc,WACvB,KAAK,eAAeP,EAAMO,CAAS,UAC1BA,IAAc,OAEvB,IAAKN,EAAIM,EAAU,OAAS,EAAGN,GAAK,EAAGA,IACrC,KAAK,eAAeD,EAAMO,EAAUN,CAAC,CAAC,EAI1C,OAAO,IACb,EAEA,SAASsB,EAAWzC,EAAQkB,EAAMwB,EAAQ,CACxC,IAAIrD,EAASW,EAAO,QAEpB,GAAIX,IAAW,OACb,MAAO,GAET,IAAIsD,EAAatD,EAAO6B,CAAI,EAC5B,OAAIyB,IAAe,OACV,GAEL,OAAOA,GAAe,WACjBD,EAAS,CAACC,EAAW,UAAYA,CAAU,EAAI,CAACA,CAAU,EAE5DD,EACLE,GAAgBD,CAAU,EAAIjB,EAAWiB,EAAYA,EAAW,MAAM,CAC1E,CAEAnC,EAAa,UAAU,UAAY,SAAmBU,EAAM,CAC1D,OAAOuB,EAAW,KAAMvB,EAAM,EAAI,CACpC,EAEAV,EAAa,UAAU,aAAe,SAAsBU,EAAM,CAChE,OAAOuB,EAAW,KAAMvB,EAAM,EAAK,CACrC,EAEAV,EAAa,cAAgB,SAASqC,EAAS3B,EAAM,CACnD,OAAI,OAAO2B,EAAQ,eAAkB,WAC5BA,EAAQ,cAAc3B,CAAI,EAE1B4B,EAAc,KAAKD,EAAS3B,CAAI,CAE3C,EAEAV,EAAa,UAAU,cAAgBsC,EACvC,SAASA,EAAc5B,EAAM,CAC3B,IAAI7B,EAAS,KAAK,QAElB,GAAIA,IAAW,OAAW,CACxB,IAAIsD,EAAatD,EAAO6B,CAAI,EAE5B,GAAI,OAAOyB,GAAe,WACxB,MAAO,GACF,GAAIA,IAAe,OACxB,OAAOA,EAAW,OAItB,MAAO,EACT,CAEAnC,EAAa,UAAU,WAAa,UAAsB,CACxD,OAAO,KAAK,aAAe,EAAIL,EAAe,KAAK,OAAO,EAAI,EAChE,EAEA,SAASuB,EAAWqB,EAAKhC,EAAG,CAE1B,QADIiC,EAAO,IAAI,MAAMjC,CAAC,EACbI,EAAI,EAAGA,EAAIJ,EAAG,EAAEI,EACvB6B,EAAK7B,CAAC,EAAI4B,EAAI5B,CAAC,EACjB,OAAO6B,CACT,CAEA,SAASV,GAAUH,EAAMc,EAAO,CAC9B,KAAOA,EAAQ,EAAId,EAAK,OAAQc,IAC9Bd,EAAKc,CAAK,EAAId,EAAKc,EAAQ,CAAC,EAC9Bd,EAAK,IAAG,CACV,CAEA,SAASS,GAAgBG,EAAK,CAE5B,QADIG,EAAM,IAAI,MAAMH,EAAI,MAAM,EACrB5B,EAAI,EAAGA,EAAI+B,EAAI,OAAQ,EAAE/B,EAChC+B,EAAI/B,CAAC,EAAI4B,EAAI5B,CAAC,EAAE,UAAY4B,EAAI5B,CAAC,EAEnC,OAAO+B,CACT,CAEA,SAASxC,GAAKmC,EAASnD,EAAM,CAC3B,OAAO,IAAI,QAAQ,SAAUyD,EAASC,EAAQ,CAC5C,SAASC,EAAc/B,EAAK,CAC1BuB,EAAQ,eAAenD,EAAM4D,CAAQ,EACrCF,EAAO9B,CAAG,CACX,CAED,SAASgC,GAAW,CACd,OAAOT,EAAQ,gBAAmB,YACpCA,EAAQ,eAAe,QAASQ,CAAa,EAE/CF,EAAQ,CAAA,EAAG,MAAM,KAAK,SAAS,CAAC,CAEtC,CACII,EAA+BV,EAASnD,EAAM4D,EAAU,CAAE,KAAM,EAAI,CAAE,EAClE5D,IAAS,SACX8D,GAA8BX,EAASQ,EAAe,CAAE,KAAM,EAAM,CAAA,CAE1E,CAAG,CACH,CAEA,SAASG,GAA8BX,EAAStB,EAASkC,EAAO,CAC1D,OAAOZ,EAAQ,IAAO,YACxBU,EAA+BV,EAAS,QAAStB,EAASkC,CAAK,CAEnE,CAEA,SAASF,EAA+BV,EAASnD,EAAMmB,EAAU4C,EAAO,CACtE,GAAI,OAAOZ,EAAQ,IAAO,WACpBY,EAAM,KACRZ,EAAQ,KAAKnD,EAAMmB,CAAQ,EAE3BgC,EAAQ,GAAGnD,EAAMmB,CAAQ,UAElB,OAAOgC,EAAQ,kBAAqB,WAG7CA,EAAQ,iBAAiBnD,EAAM,SAASgE,EAAa5C,EAAK,CAGpD2C,EAAM,MACRZ,EAAQ,oBAAoBnD,EAAMgE,CAAY,EAEhD7C,EAASC,CAAG,CAClB,CAAK,MAED,OAAM,IAAI,UAAU,sEAAwE,OAAO+B,CAAO,CAE9G,CChfA,MAAMc,GAAgB,CAACC,EAAQC,IAAiBA,EAAa,KAAMC,GAAMF,aAAkBE,CAAC,EAE5F,IAAIC,EACAC,EAEJ,SAASC,IAAuB,CAC5B,OAAQF,IACHA,EAAoB,CACjB,YACA,eACA,SACA,UACA,cACZ,EACA,CAEA,SAASG,IAA0B,CAC/B,OAAQF,IACHA,EAAuB,CACpB,UAAU,UAAU,QACpB,UAAU,UAAU,SACpB,UAAU,UAAU,kBAChC,EACA,CACA,MAAMG,EAAmB,IAAI,QACvBC,EAAqB,IAAI,QACzBC,EAA2B,IAAI,QAC/BC,EAAiB,IAAI,QACrBC,EAAwB,IAAI,QAClC,SAASC,GAAiBC,EAAS,CAC/B,MAAMC,EAAU,IAAI,QAAQ,CAACvB,EAASC,IAAW,CAC7C,MAAMuB,EAAW,IAAM,CACnBF,EAAQ,oBAAoB,UAAWG,CAAO,EAC9CH,EAAQ,oBAAoB,QAASI,CAAK,CACtD,EACcD,EAAU,IAAM,CAClBzB,EAAQ2B,EAAKL,EAAQ,MAAM,CAAC,EAC5BE,GACZ,EACcE,EAAQ,IAAM,CAChBzB,EAAOqB,EAAQ,KAAK,EACpBE,GACZ,EACQF,EAAQ,iBAAiB,UAAWG,CAAO,EAC3CH,EAAQ,iBAAiB,QAASI,CAAK,CAC/C,CAAK,EACD,OAAAH,EACK,KAAMnE,GAAU,CAGbA,aAAiB,WACjB4D,EAAiB,IAAI5D,EAAOkE,CAAO,CAG/C,CAAK,EACI,MAAM,IAAM,CAAA,CAAG,EAGpBF,EAAsB,IAAIG,EAASD,CAAO,EACnCC,CACX,CACA,SAASK,GAA+BC,EAAI,CAExC,GAAIZ,EAAmB,IAAIY,CAAE,EACzB,OACJ,MAAMC,EAAO,IAAI,QAAQ,CAAC9B,EAASC,IAAW,CAC1C,MAAMuB,EAAW,IAAM,CACnBK,EAAG,oBAAoB,WAAYE,CAAQ,EAC3CF,EAAG,oBAAoB,QAASH,CAAK,EACrCG,EAAG,oBAAoB,QAASH,CAAK,CACjD,EACcK,EAAW,IAAM,CACnB/B,IACAwB,GACZ,EACcE,EAAQ,IAAM,CAChBzB,EAAO4B,EAAG,OAAS,IAAI,aAAa,aAAc,YAAY,CAAC,EAC/DL,GACZ,EACQK,EAAG,iBAAiB,WAAYE,CAAQ,EACxCF,EAAG,iBAAiB,QAASH,CAAK,EAClCG,EAAG,iBAAiB,QAASH,CAAK,CAC1C,CAAK,EAEDT,EAAmB,IAAIY,EAAIC,CAAI,CACnC,CACA,IAAIE,EAAgB,CAChB,IAAInF,EAAQoF,EAAMnF,EAAU,CACxB,GAAID,aAAkB,eAAgB,CAElC,GAAIoF,IAAS,OACT,OAAOhB,EAAmB,IAAIpE,CAAM,EAExC,GAAIoF,IAAS,mBACT,OAAOpF,EAAO,kBAAoBqE,EAAyB,IAAIrE,CAAM,EAGzE,GAAIoF,IAAS,QACT,OAAOnF,EAAS,iBAAiB,CAAC,EAC5B,OACAA,EAAS,YAAYA,EAAS,iBAAiB,CAAC,CAAC,EAI/D,OAAO6E,EAAK9E,EAAOoF,CAAI,CAAC,CAC3B,EACD,IAAIpF,EAAQoF,EAAM7E,EAAO,CACrB,OAAAP,EAAOoF,CAAI,EAAI7E,EACR,EACV,EACD,IAAIP,EAAQoF,EAAM,CACd,OAAIpF,aAAkB,iBACjBoF,IAAS,QAAUA,IAAS,SACtB,GAEJA,KAAQpF,CAClB,CACL,EACA,SAASqF,GAAaC,EAAU,CAC5BH,EAAgBG,EAASH,CAAa,CAC1C,CACA,SAASI,GAAaC,EAAM,CAIxB,OAAIA,IAAS,YAAY,UAAU,aAC/B,EAAE,qBAAsB,eAAe,WAChC,SAAUC,KAAevF,EAAM,CAClC,MAAM8E,EAAKQ,EAAK,KAAK9C,EAAO,IAAI,EAAG+C,EAAY,GAAGvF,CAAI,EACtD,OAAAmE,EAAyB,IAAIW,EAAIS,EAAW,KAAOA,EAAW,KAAM,EAAG,CAACA,CAAU,CAAC,EAC5EX,EAAKE,CAAE,CAC1B,EAOQd,GAAyB,EAAC,SAASsB,CAAI,EAChC,YAAatF,EAAM,CAGtB,OAAAsF,EAAK,MAAM9C,EAAO,IAAI,EAAGxC,CAAI,EACtB4E,EAAKX,EAAiB,IAAI,IAAI,CAAC,CAClD,EAEW,YAAajE,EAAM,CAGtB,OAAO4E,EAAKU,EAAK,MAAM9C,EAAO,IAAI,EAAGxC,CAAI,CAAC,CAClD,CACA,CACA,SAASwF,GAAuBnF,EAAO,CACnC,OAAI,OAAOA,GAAU,WACVgF,GAAahF,CAAK,GAGzBA,aAAiB,gBACjBwE,GAA+BxE,CAAK,EACpCoD,GAAcpD,EAAO0D,IAAsB,EACpC,IAAI,MAAM1D,EAAO4E,CAAa,EAElC5E,EACX,CACA,SAASuE,EAAKvE,EAAO,CAGjB,GAAIA,aAAiB,WACjB,OAAOiE,GAAiBjE,CAAK,EAGjC,GAAI+D,EAAe,IAAI/D,CAAK,EACxB,OAAO+D,EAAe,IAAI/D,CAAK,EACnC,MAAMoF,EAAWD,GAAuBnF,CAAK,EAG7C,OAAIoF,IAAapF,IACb+D,EAAe,IAAI/D,EAAOoF,CAAQ,EAClCpB,EAAsB,IAAIoB,EAAUpF,CAAK,GAEtCoF,CACX,CACA,MAAMjD,EAAUnC,GAAUgE,EAAsB,IAAIhE,CAAK,EC5KzD,SAASqF,GAAOlG,EAAMmG,EAAS,CAAE,QAAAC,EAAS,QAAAC,EAAS,SAAAC,EAAU,WAAAC,CAAY,EAAG,GAAI,CAC5E,MAAMxB,EAAU,UAAU,KAAK/E,EAAMmG,CAAO,EACtCK,EAAcpB,EAAKL,CAAO,EAChC,OAAIsB,GACAtB,EAAQ,iBAAiB,gBAAkB3F,GAAU,CACjDiH,EAAQjB,EAAKL,EAAQ,MAAM,EAAG3F,EAAM,WAAYA,EAAM,WAAYgG,EAAKL,EAAQ,WAAW,EAAG3F,CAAK,CAC9G,CAAS,EAEDgH,GACArB,EAAQ,iBAAiB,UAAY3F,GAAUgH,EAE/ChH,EAAM,WAAYA,EAAM,WAAYA,CAAK,CAAC,EAE9CoH,EACK,KAAMC,GAAO,CACVF,GACAE,EAAG,iBAAiB,QAAS,IAAMF,EAAY,CAAA,EAC/CD,GACAG,EAAG,iBAAiB,gBAAkBrH,GAAUkH,EAASlH,EAAM,WAAYA,EAAM,WAAYA,CAAK,CAAC,CAE/G,CAAK,EACI,MAAM,IAAM,CAAA,CAAG,EACboH,CACX,CAgBA,MAAME,GAAc,CAAC,MAAO,SAAU,SAAU,aAAc,OAAO,EAC/DC,GAAe,CAAC,MAAO,MAAO,SAAU,OAAO,EAC/CC,EAAgB,IAAI,IAC1B,SAASC,EAAUvG,EAAQoF,EAAM,CAC7B,GAAI,EAAEpF,aAAkB,aACpB,EAAEoF,KAAQpF,IACV,OAAOoF,GAAS,UAChB,OAEJ,GAAIkB,EAAc,IAAIlB,CAAI,EACtB,OAAOkB,EAAc,IAAIlB,CAAI,EACjC,MAAMoB,EAAiBpB,EAAK,QAAQ,aAAc,EAAE,EAC9CqB,EAAWrB,IAASoB,EACpBE,EAAUL,GAAa,SAASG,CAAc,EACpD,GAEA,EAAEA,KAAmBC,EAAW,SAAW,gBAAgB,YACvD,EAAEC,GAAWN,GAAY,SAASI,CAAc,GAChD,OAEJ,MAAMG,EAAS,eAAgBC,KAAc1G,EAAM,CAE/C,MAAM8E,EAAK,KAAK,YAAY4B,EAAWF,EAAU,YAAc,UAAU,EACzE,IAAI1G,EAASgF,EAAG,MAChB,OAAIyB,IACAzG,EAASA,EAAO,MAAME,EAAK,MAAO,CAAA,IAM9B,MAAM,QAAQ,IAAI,CACtBF,EAAOwG,CAAc,EAAE,GAAGtG,CAAI,EAC9BwG,GAAW1B,EAAG,IAC1B,CAAS,GAAG,CAAC,CACb,EACI,OAAAsB,EAAc,IAAIlB,EAAMuB,CAAM,EACvBA,CACX,CACAtB,GAAcwB,IAAc,CACxB,GAAGA,EACH,IAAK,CAAC7G,EAAQoF,EAAMnF,IAAasG,EAAUvG,EAAQoF,CAAI,GAAKyB,EAAS,IAAI7G,EAAQoF,EAAMnF,CAAQ,EAC/F,IAAK,CAACD,EAAQoF,IAAS,CAAC,CAACmB,EAAUvG,EAAQoF,CAAI,GAAKyB,EAAS,IAAI7G,EAAQoF,CAAI,CACjF,EAAE,ECCK,MAAM0B,WAAqBtG,CAAa,CAC3C,OAAe,UACP,aACA,UACD,KAEC,SACA,oBACA,QAAU,GACV,YAAwB,CAAA,EACxB,UAAuB,IACvB,QACA,YAAc,GACd,SACA,YACA,WACA,UAER,IAAW,YAAsB,CAC7B,OAAO,KAAK,eAAiB,MACjC,CAEA,aAAoB,UAAW,CAC3B,IAAIuG,EAAW,KAAK,UAEpB,GAAI,CAACA,EAAU,CACCA,EAAA,KAAK,UAAY,IAAI,KAC5BA,EAAS,UACV,MAAMA,EAAS,iBAEnB,MAAM/B,EAAK+B,EAAS,UAAU,YAAY,YAAa,UAAU,EAE3DC,EAAY,MAAMhC,GAAI,MAAM,OAAO,EAErC,GADJ,MAAMA,GAAI,KACNgC,GAAaA,EAAU,OAAS,EAAG,CAC1BD,EAAA,KAAOC,EAAU,CAAC,EAAE,OACpBD,EAAA,SAAWC,EAAU,CAAC,EAAE,SACxBD,EAAA,oBAAsBC,EAAU,CAAC,EAAE,oBACnCD,EAAA,aAAeC,EAAU,CAAC,EAAE,aAC5BD,EAAA,UAAYC,EAAU,CAAC,EAAE,UAClCD,EAAS,YAAc,CACnB,WAAYC,EAAU,CAAC,EAAE,UACzB,YAAaA,EAAU,CAAC,EAAE,WAAA,EAI9B,MAAMC,EAASF,EAAS,UAAU,YAAY,WAAY,UAAU,EAC9DG,EAAW,MAAMD,GAAQ,MAAM,IAAIF,EAAS,IAAK,EACvD,MAAME,GAAQ,KAEVC,IACAH,EAAS,QAAUG,EAAS,QAC5BH,EAAS,YAAcG,EAAS,YAChCH,EAAS,WAAaG,EAAS,WAC/BH,EAAS,UAAYG,EAAS,WAIlC,MAAMC,EAASJ,EAAS,UAAU,YAAY,QAAS,UAAU,EAC3DK,EAAQ,MAAMD,GAAQ,MAAM,OAAO,EACzC,MAAMA,GAAQ,KAEVC,IACAL,EAAS,MAAQ,IAAI,IAAIK,EAAM,IAAYC,GAAA,CACvC,MAAMC,EAAU,IAAIpI,EAAKmI,EAAK,OAAQN,EAAS,QAAS,EACxD,OAAAO,EAAQ,UAAYD,EAAK,UACjBC,EAAA,gBAAgBD,EAAK,aAAa,EAClCC,EAAA,eAAeD,EAAK,YAAY,EAChCC,EAAA,qBAAqBD,EAAK,kBAAkB,EAC5CC,EAAA,8BAA8BD,EAAK,eAAe,EAClDC,EAAA,QAAQD,EAAK,IAAI,EACrBA,EAAK,QACGC,EAAA,UAAUD,EAAK,MAAM,EAE7BA,EAAK,aACGC,EAAA,eAAeD,EAAK,WAAW,EAEpCC,CACV,CAAA,CAAC,EACOP,EAAA,KAAK,QAASA,EAAS,KAAK,IAM1C,OAAAA,CACX,CAEA,MAAc,gBAAiB,CAC3B,KAAK,SAAW,MAAMnB,GAAiB,SAAU,EAAG,CAChD,QAAQO,EAAI,CACJA,EAAG,iBAAiB,SAAS,OAAO,GACpCA,EAAG,kBAAkB,OAAO,EAK5BA,EAAG,iBAAiB,SAAS,UAAU,GACvCA,EAAG,kBAAkB,UAAU,EAEnCA,EAAG,kBAAkB,QAAS,CAAE,QAAS,QAAU,CAAA,EACnDA,EAAG,kBAAkB,YAAa,CAAE,QAAS,QAAU,CAAA,EACvDA,EAAG,kBAAkB,WAAY,CAAE,QAAS,QAAU,CAAA,CAC1D,CAAA,CACH,CACL,CAEA,MAAc,YAAY/G,EAAkB,CACxC,GAAI,CAACA,EAAS,WAAW,UAAU,EAC/B,MAAM,MAAM,qCAAqC,EAEhD,KAAK,UACN,MAAM,KAAK,iBAIf,MAAM4F,EAAK,KAAK,UAAU,YAAY,YAAa,WAAW,EACxD,MAAAA,GAAI,MAAM,IAAI,CAChB,OAAQ,KAAK,KACb,SAAA5F,EACA,oBAAqB,KAAK,oBAC1B,aAAc,KAAK,aACnB,UAAW,KAAK,SAAA,CACnB,EACD,MAAM4F,GAAI,KAGV,KAAK,SAAW5F,CAEpB,CAEA,MAAa,WAAY,CACjB,GAAA,CAAC,KAAK,WACN,MAAM,MAAM,eAAe,EAK/B,GAHK,KAAK,UACN,MAAM,KAAK,iBAEX,MAAK,QAIT,IADA,KAAK,QAAU,GACR,KAAK,SACJ,GAAA,CACA,MAAM,KAAK,aACNmI,GACL,QAAQ,MAAMA,CAAC,EACf,MACJ,CAER,CAEO,UAAW,CACd,KAAK,QAAU,EACnB,CAEQ,eAAetE,EAAeuE,EAA6B,CAC/D,UAAWC,KAAKD,EACZ,GAAIC,EAAE,CAAC,EAAIxE,GAASA,GAASwE,EAAE,CAAC,EACrB,MAAA,GAGR,MAAA,EACX,CAEQ,WAAWC,EAAiBF,EAAoBG,EAAYC,EAAa,CAI7E,QAASzG,EAAIwG,EAAK,EAAGxG,EAAIyG,EAAM,EAAGzG,IAC9B,GAAI,KAAK,eAAeA,EAAGqG,CAAM,EAAG,CAChC,MAAMF,EAAU,CAAC,GAAG,KAAK,KAAK,EAAE,KAAKD,GAAQA,EAAK,UAAUK,CAAO,IAAMvG,EAAI,CAAC,EAC1EmG,IACQA,EAAA,UAAUI,CAAO,EAAKvG,GAI9C,CAEQ,UAAUuG,EAAiBF,EAAoBG,EAAYC,EAAa,CAI5E,QAASzG,EAAIyG,EAAM,EAAGzG,EAAIwG,EAAK,EAAGxG,IAC9B,GAAI,KAAK,eAAeA,EAAGqG,CAAM,EAAG,CAChC,MAAMF,EAAU,CAAC,GAAG,KAAK,KAAK,EAAE,KAAKD,GAAQA,EAAK,UAAUK,CAAO,IAAMvG,EAAI,CAAC,EAC1EmG,IACQA,EAAA,UAAUI,CAAO,EAAKvG,GAK9C,CAEQ,YAAYuG,EAAiBF,EAAoBvE,EAAe,CAEpE,IAAI4E,EAAM,GACJ,MAAAC,EAAU,CAAC,GAAG,KAAK,KAAK,EAAE,IAAYT,GAAAA,EAAK,UAAUK,CAAO,CAAC,EACnE,UAAW3G,KAAK+G,EACR,OAAO/G,CAAC,EAAI8G,IACZA,EAAM,OAAO9G,CAAC,GAGlB8G,EAAM,GAAK5E,EAAQ4E,GAIvB,KAAK,UAAUH,EAASF,EAAQK,EAAK5E,CAAK,CAC9C,CAEQ,SAASyE,EAAiBF,EAAoBvE,EAAqB,CAEvE,IAAI4E,EAAM,GACJ,MAAAC,EAAU,CAAC,GAAG,KAAK,KAAK,EAAE,IAAYT,GAAAA,EAAK,UAAUK,CAAO,CAAC,EACnE,UAAW3G,KAAK+G,EACR,OAAO/G,CAAC,EAAI8G,IACZA,EAAM,OAAO9G,CAAC,GAGlB8G,EAAM,GAAK5E,EAAQ4E,GAIvB,KAAK,WAAWH,EAASF,EAAQK,EAAM,EAAG5E,CAAK,CACnD,CAEA,MAAc,MAAO,CACb,GAAA,CAAC,KAAK,WACN,MAAM,MAAM,eAAe,EAE3B,GAAA,CAAC,KAAK,oBACN,MAAM,MAAM,4BAA4B,EAI5C,IAAI8E,EAGA,CACA,SAAY,CAAC,CAAC,EAAG,EAAE,CAAC,EAEpB,OAAU,CAAC,CAAC,EAAG,OAAO,gBAAgB,CAAC,CAAA,EAEvCC,EAAiB,EACjB,GAAA,CAAC,KAAK,YACN,UAAW7F,KAAQ4F,EAAc,CAEZC,EAAA,GAGX,MAAAC,EAAiB,CAAC,GAAG,KAAK,KAAK,EAChC,OAAeZ,GAAA,KAAK,YAAY,SAASA,EAAK,MAAM,CAAC,EACrD,IAAIA,GAAQA,EAAK,UAAUlF,CAAI,CAAC,EAChC,OAIL8F,EAAe,KAAKA,EAAeA,EAAe,OAAS,CAAC,EAAI,CAAC,EAGjE,MAAMC,EAAeD,EAAe,OAAO,CAACE,EAAKC,EAAKjH,EAAG4B,IACjD5B,IAAM,GAENgH,EAAI,KAAK,CAACC,EAAKA,CAAG,CAAC,EACZD,GAGPC,IAAQrF,EAAI5B,EAAI,CAAC,EAAI,GAErBgH,EAAIA,EAAI,OAAS,CAAC,EAAE,CAAC,EAAIC,EAClBD,IAGXA,EAAI,KAAK,CAACC,EAAKA,CAAG,CAAC,EACZD,GACR,CAAwB,CAAA,EAE3BJ,EAAa5F,CAAI,EAAI+F,EAKzB,KAAK,YAAc,OAAO,QAAQH,CAAY,EAAE,aAAe,OAAO,QAAQ,KAAK,UAAU,EAAE,aAC/F,QAAQ,IAAI,uCAAuC,EACnD,KAAK,WAAaA,EAClB,KAAK,UAAY,KAAK,IAAI,EAAE,SAAS,GAGpC,KAAK,aACN,KAAK,WAAaA,EAClB,KAAK,UAAY,KAAK,IAAI,EAAE,SAAS,GAIrC,IAAAM,EAAM,GAAG,KAAK,oFACd,KAAK,UACCA,EAAA,GAAG,KAAK,yFAAyF,KAAK,WAG1G,MAAAC,EAAO,MAAM,MAAMD,EAAK,CAC1B,OAAQ,OACR,QAAS,CACL,cAAiB,UAAU,KAAK,cACpC,EACA,KAAM,KAAK,UAAU,CAIjB,OAAQ,KAAK,UAQb,MAAO,CAEH,OAAU,CACN,mBAAoB,GACpB,KAAM,CAAC,SAAS,EAChB,eAAgB,CAEZ,CAAC,gBAAiB,GAAG,EACrB,CAAC,iBAAkB,GAAG,EACtB,CAAC,gBAAiB,EAAE,EAEpB,CAAC,gBAAiB,GAAG,CACzB,EACA,eAAAL,EACA,QAAS,CACL,WAAY,CAAC,SAAS,CAC1B,CACJ,EACA,SAAY,CACR,OAAQ,KAAK,WAAW,SACxB,KAAM,CAAC,wBAAyB,aAAc,SAAS,EACvD,eAAgB,CAEZ,CAAC,gBAAiB,GAAG,EACrB,CAAC,iBAAkB,GAAG,EACtB,CAAC,gBAAiB,EAAE,EAEpB,CAAC,gBAAiB,GAAG,CACzB,EACA,eAAAA,EACA,QAAS,CAAC,CACd,CACJ,EACA,iBAAkB,CAAC,iBAAkB,kBAAkB,CAAA,CAK1D,CAAA,CACJ,EACG,GAAA,CAACM,EAAK,GAAI,CACN,GAAAA,EAAK,SAAW,MACX,MAAMA,EAAK,KAAK,GAAG,UAAY,gBAAiB,CACjD,KAAK,QAAU,OACf,MAAMC,EAAa,KAAK,UAAU,YAAY,WAAY,WAAW,EAC/DA,MAAAA,GAAY,MAAM,IAAI,CACxB,OAAQ,KAAK,KACb,QAAS,KAAK,QACd,YAAa,KAAK,YAClB,WAAY,KAAK,WACjB,UAAW,KAAK,SAAA,CACnB,EACD,MAAMA,GAAY,KAG1B,cAAQ,MAAMD,CAAI,EACZ,MAAM,uCAAuC,EAEjD,MAAAE,EAAO,MAAMF,EAAK,OACxB,KAAK,QAAUE,EAAK,IAGpB,MAAMD,EAAa,KAAK,UAAU,YAAY,WAAY,WAAW,EAC/D,MAAAA,GAAY,MAAM,IAAI,CACxB,OAAQ,KAAK,KACb,QAAS,KAAK,QACd,YAAa,KAAK,YAClB,WAAY,KAAK,WACjB,UAAW,KAAK,SAAA,CACnB,EACD,MAAMA,GAAY,KAElB,IAAIE,EAAW,GACJ,UAAAf,KAAWc,EAAK,MAAO,CACxB,MAAArG,EAAOqG,EAAK,MAAMd,CAAO,EAC/B,GAAIvF,EAAK,IAAK,CACC,UAAA1D,KAAM0D,EAAK,IACd,GAAA3D,EAASC,CAAE,EAAG,CACd,MAAMuG,EAAK,KAAK,UAAU,YAAY,QAAS,WAAW,EACjD,QAAA7D,EAAI1C,EAAG,MAAM,CAAC,EAAG0C,GAAK1C,EAAG,MAAM,CAAC,EAAG0C,IAAK,CAC7C,MAAMhC,EAASV,EAAG,SAAS0C,EAAI1C,EAAG,MAAM,CAAC,CAAC,EAC1C,GAAI,CAACU,EACD,MAKE,MAAAmI,EAAU,CAAC,GAAG,KAAK,KAAK,EAAE,KAAKD,GAAQA,EAAK,SAAWlI,CAAM,EACnE,GAAImI,EAAS,CACDA,EAAA,UAAUI,CAAO,EAAIvG,EAC7B,SAIJ,MAAMuH,EAAU,IAAIxJ,EAAKC,EAAQ,KAAK,QAAS,EAC/CuJ,EAAQ,QAAQvJ,CAAM,EACduJ,EAAA,UAAUhB,CAAO,EAAIvG,EAExB,KAAA,MAAM,IAAIuH,CAAO,EAChB1D,MAAAA,GAAI,MAAM,IAAI,CAChB,UAAW0D,EAAQ,UACnB,OAAQA,EAAQ,OAChB,KAAMA,EAAQ,QAAQ,EACtB,mBAAoBA,EAAQ,qBAAqB,EACjD,gBAAiBA,EAAQ,8BAA8B,EACvD,aAAcA,EAAQ,eAAe,EACrC,cAAeA,EAAQ,gBAAgB,EACvC,UAAWA,EAAQ,aAAa,EAChC,QAASA,EAAQ,QAAQ,CAAA,CAC5B,EAEL,MAAM1D,GAAI,aACHtG,EAAWD,CAAE,EAAG,CACf,QAAA,IAAI,gBAAiBA,CAAE,EACf,CAAC,GAAG,KAAK,KAAK,EAAE,KAAK4I,GAAQA,EAAK,UAAUK,CAAO,IAAMjJ,EAAG,KAAK,IAEzEgK,EAAW,EAEX,KAAK,SAASf,EAAS,KAAK,WAAWA,CAAO,EAAGjJ,EAAG,KAAK,EAClDgK,EAAWhK,EAAG,MAQhB,KAAA,WAAWiJ,EAAS,KAAK,WAAWA,CAAO,EAAGe,EAAUhK,EAAG,KAAK,EAC9DgK,EAAWhK,EAAG,OAGhB,KAAA,UAAUiJ,EAAS,KAAK,WAAWA,CAAO,EAAGjJ,EAAG,MAAOgK,CAAQ,GAGjEA,EAAA,GACX,MAAMzD,EAAK,KAAK,UAAU,YAAY,QAAS,WAAW,EAEpD2D,EAAY,CAAC,GAAG,KAAK,KAAK,EAAE,KAAatB,GAAAA,EAAK,SAAW5I,EAAG,OAAO,EACzE,GAAIkK,EACUA,EAAA,UAAUjB,CAAO,EAAIjJ,EAAG,MAC5BuG,MAAAA,GAAI,MAAM,IAAI,CAChB,UAAW2D,EAAU,UACrB,OAAQA,EAAU,OAClB,KAAMA,EAAU,QAAQ,EACxB,mBAAoBA,EAAU,qBAAqB,EACnD,gBAAiBA,EAAU,8BAA8B,EACzD,aAAcA,EAAU,eAAe,EACvC,cAAeA,EAAU,gBAAgB,EACzC,UAAWA,EAAU,aAAa,EAClC,QAASA,EAAU,QAAQ,CAAA,CAC9B,MACE,CACH,MAAMD,EAAU,IAAIxJ,EAAKT,EAAG,QAAS,KAAK,QAAS,EAC3CiK,EAAA,QAAQjK,EAAG,OAAO,EAClBiK,EAAA,UAAUhB,CAAO,EAAIjJ,EAAG,MAC3B,KAAA,MAAM,IAAIiK,CAAO,EAChB1D,MAAAA,GAAI,MAAM,IAAI,CAChB,UAAW0D,EAAQ,UACnB,OAAQA,EAAQ,OAChB,KAAMA,EAAQ,QAAQ,EACtB,mBAAoBA,EAAQ,qBAAqB,EACjD,gBAAiBA,EAAQ,8BAA8B,EACvD,aAAcA,EAAQ,eAAe,EACrC,cAAeA,EAAQ,gBAAgB,EACvC,UAAWA,EAAQ,aAAa,EAChC,QAASA,EAAQ,QAAQ,CAAA,CAC5B,EAGC,MAAAE,EAAW,CAAC,GAAG,KAAK,KAAK,EAAE,IAAYvB,GAAAA,EAAK,MAAM,EAElDwB,EAAaD,EAAS,OAAO,CAACE,EAAM7F,IAAU2F,EAAS,QAAQE,CAAI,GAAK7F,CAAK,EAC/E4F,EAAW,OAAS,GACZ,QAAA,MAAM,mBAAoBA,CAAU,EAEhD,MAAM7D,GAAI,aACHpG,EAAWH,CAAE,EAAG,CACf,QAAA,IAAI,gBAAiBA,CAAE,EAE/B,MAAM6I,EAAU,CAAC,GAAG,KAAK,KAAK,EAAE,KAAKD,GAAQA,EAAK,UAAUK,CAAO,IAAMjJ,EAAG,KAAK,EACjF,GAAI6I,EAAS,CACT,MAAMtC,EAAK,KAAK,UAAU,YAAY,QAAS,WAAW,EAC1D,MAAMA,GAAI,MAAM,OAAOsC,EAAQ,MAAM,EACrC,MAAMtC,GAAI,KACL,KAAA,MAAM,OAAOsC,CAAO,EAEzBmB,IAAa,IAEb,KAAK,YAAYf,EAAS,KAAK,WAAWA,CAAO,EAAGe,CAAQ,EAEhEA,EAAWhK,EAAG,cACPE,EAAeF,CAAE,EAAG,CAC3B,MAAMuG,EAAK,KAAK,UAAU,YAAY,QAAS,WAAW,EACjD,QAAA7D,EAAI1C,EAAG,MAAM,CAAC,EAAG0C,GAAK1C,EAAG,MAAM,CAAC,EAAG0C,IAAK,CAE7C,MAAMmG,EAAU,CAAC,GAAG,KAAK,KAAK,EAAE,KAAKD,GAAQA,EAAK,UAAUK,CAAO,IAAMvG,CAAC,EACtEmG,IACA,MAAMtC,GAAI,MAAM,OAAOsC,EAAQ,MAAM,EAChC,KAAA,MAAM,OAAOA,CAAO,GAGjC,MAAMtC,GAAI,KAGdyD,IAAa,IAGb,KAAK,YAAYf,EAAS,KAAK,WAAWA,CAAO,EAAGe,CAAQ,GAIxE,MAAMzD,EAAK,KAAK,UAAU,YAAY,QAAS,WAAW,EAC/C,UAAA7F,KAAUqJ,EAAK,MAAO,CACvB,MAAAnB,EAAOmB,EAAK,MAAMrJ,CAAM,EACxBO,EAAO2H,EAAK,KACZ0B,EAAqB1B,EAAK,mBAC1B2B,EAA+B3B,EAAK,gBACpC4B,EAAe5B,EAAK,aACpB6B,EAAgB7B,EAAK,cACrBhI,EAASgI,EAAK,SACd8B,EAAiB9B,EAAK,eAEtBC,EAAU,CAAC,GAAG,KAAK,KAAK,EAAE,KAAKD,GAAQA,EAAK,SAAWlI,CAAM,EACnE,GAAI,CAACmI,EAAS,CAEF,QAAA,MAAM,oCAAqCnI,CAAM,EACzD,SAGAO,GACA4H,EAAQ,QAAQ5H,CAAI,EAExB4H,EAAQ,qBAAqByB,CAAkB,EAC/CzB,EAAQ,8BAA8B0B,CAA4B,EAClE1B,EAAQ,eAAe2B,CAAY,EACnC3B,EAAQ,gBAAgB4B,CAAa,EACjC7J,GACAiI,EAAQ,UAAUjI,CAAM,EAExB8J,GACA7B,EAAQ,eAAe6B,CAAc,EAInC,MAAAnE,GAAI,MAAM,IAAI,CAChB,UAAWsC,EAAQ,UACnB,OAAQA,EAAQ,OAChB,KAAMA,EAAQ,QAAQ,EACtB,mBAAoBA,EAAQ,qBAAqB,EACjD,gBAAiBA,EAAQ,8BAA8B,EACvD,aAAcA,EAAQ,eAAe,EACrC,cAAeA,EAAQ,gBAAgB,EACvC,OAAAjI,EACA,YAAa8J,EACb,UAAW7B,EAAQ,aAAa,EAChC,QAASA,EAAQ,QAAQ,CAAA,CAC5B,EAEL,MAAMtC,GAAI,KACNwD,EAAK,OAAS,OAAO,KAAKA,EAAK,KAAK,EAAE,OAAS,GAC1C,KAAA,KAAK,QAAS,KAAK,KAAK,CAErC,CAOO,cAAcrJ,EAAgB,CAC5B,KAAA,YAAY,KAAKA,CAAM,CAChC,CAOO,iBAAiBA,EAAgB,CACpC,KAAK,YAAc,KAAK,YAAY,OAAOkI,GAAQA,IAASlI,CAAM,CACtE,CAEO,UAAsB,CACzB,OAAO,KAAK,KAChB,CAEQ,WAAoB,CACxB,MAAO,CAAC,GAAG,KAAK,KAAK,EAAE,OAAOkI,GAAQA,EAAK,QAAA,CAAS,EAAE,KAAK,CAAC+B,EAASC,IAC7DD,EAAE,QAAA,EAAYC,EAAE,UACT,GAEPD,EAAE,QAAA,EAAYC,EAAE,UACT,EAEJ,CACV,CACL,CAEO,oBAEJ,CACO,MAAAC,EAAS,KAAK,YACdC,MAEG,IAET,UAAWC,KAASF,EAAQ,CAClB,MAAAG,EAAcD,EAAM,sBAEpB5J,EAAW,IAAI,IAAI,CAAC,GAAG,KAAK,SAAS,CAAC,EAAE,UAAe6J,EAAY,SAASpC,EAAK,MAAM,CAAC,CAAC,EAE/FkC,EAAO,IAAI,CACP,UAAWC,EACX,SAAA5J,CAAA,CACH,EAIM,UAAAyH,KAAQ,KAAK,WAAY,CAC1B,MAAAxH,EAAUwH,EAAK,oBACrB,UAAWqC,KAAU7J,EAAS,CAC1B,MAAM8J,EAAY,CAAC,GAAG,KAAK,SAAU,CAAA,EAAE,KAAKtC,GAAQA,EAAK,SAAWqC,EAAO,MAAM,EACjF,GAAI,CAACC,EACD,SAEE,MAAAC,EAAoB,CAAC,GAAGL,CAAM,EAAE,KAAKC,GAASA,EAAM,UAAU,SAAWG,EAAU,MAAM,EAC/F,GAAIC,EAAmB,CAEd,CAAC,GAAGA,EAAkB,QAAQ,EAAE,KAAKC,GAASA,EAAM,SAAWxC,EAAK,MAAM,GACzDuC,EAAA,SAAS,IAAIvC,CAAI,EAEvC,SAGJkC,EAAO,IAAI,CACP,UAAWI,EACX,SAAU,IAAI,IAAI,CAACtC,CAAI,CAAC,CAAA,CAC3B,GAIF,OAAAkC,CACX,CAEA,MAAc,eAAsC,CAC5C,GAAA,CAAC,KAAK,SACN,MAAM,MAAM,4BAA4B,EAE5C,MAAMjB,EAAO,MAAM,MAAM,GAAG,KAAK,kCAAkC,EAC/D,GAAA,CAACA,EAAK,GACN,cAAQ,MAAMA,CAAI,EACZ,MAAM,sDAAsD,EAG/D,OADM,MAAMA,EAAK,MAE5B,CAEA,MAAc,cAAoC,CAC1C,GAAA,CAAC,KAAK,SACN,MAAM,MAAM,4BAA4B,EAE5C,MAAMA,EAAO,MAAM,MAAM,GAAG,KAAK,oCAAoC,EACjE,GAAA,CAACA,EAAK,GACN,cAAQ,MAAMA,CAAI,EACZ,MAAM,sDAAsD,EAG/D,OADM,MAAMA,EAAK,MAE5B,CAEA,MAAa,cAAcwB,EAAkBC,EAAkBC,EAAY,EAAG,CAI1E,GAHK,KAAK,UACN,MAAM,KAAK,iBAEX,CAACF,EACD,MAAM,MAAM,sBAAsB,EAEtC,GAAI,CAACC,EACD,MAAM,MAAM,sBAAsB,EAEtC,KAAK,KAAOD,EACN,MAAA,KAAK,YAAY,WAAWA,EAAS,MAAM,GAAG,EAAE,CAAC,GAAG,EAEtD,GAAA,CACM,MAAAG,EAAa,MAAM,KAAK,eAI1B,GAHAA,EAAW,cAAc,GAAG,UAC5B,MAAM,KAAK,YAAYA,EAAW,cAAc,EAAE,QAAQ,EAE1DA,EAAW,0BAA0B,GAAG,IAAK,CAE7C,MAAMjF,EAAK,KAAK,UAAU,YAAY,YAAa,WAAW,EACxD,MAAAA,GAAI,MAAM,IAAI,CAChB,OAAQ,KAAK,KACb,SAAU,KAAK,SACf,oBAAqBiF,EAAW,0BAA0B,EAAE,IAC5D,aAAc,KAAK,aACnB,UAAW,KAAK,SAAA,CACnB,EACD,MAAMjF,GAAI,KAGL,KAAA,oBAAsBiF,EAAW,0BAA0B,EAAE,QAElE,OAAM,MAAM,6BAA6B,QAExC1C,GACG,QAAA,KAAK,2BAA2B,KAAK;AAAA,EAAcA,GAAG,CAClE,CAGK,KADc,MAAM,KAAK,iBACd,MAAM,OAAQ2C,GAASA,EAAK,OAAS,kBAAkB,GAAG,QAAU,IAAM,EACtF,MAAM,MAAM,oDAAoD,EAGpE,MAAM5B,EAAO,MAAM,MAAM,GAAG,KAAK,mCAAoC,CACjE,OAAQ,OACR,QAAS,CACL,eAAgB,kBACpB,EACA,KAAM,KAAK,UAAU,CACjB,KAAM,mBACN,WAAY,CACR,KAAM,YACN,KAAMwB,CACV,EACA,KAAMA,EACN,SAAAC,CAAA,CACH,CAAA,CACJ,EACG,GAAA,CAACzB,EAAK,GACN,cAAQ,MAAMA,CAAI,EACZ,MAAM,0CAA0C,EAEpD,MAAAE,EAAO,MAAMF,EAAK,OACpB,GAAA6B,GAAY3B,CAAI,EAChB,MAAM,MAAM,qBAAqBA,EAAK,YAAYA,EAAK,OAAO,EAM9D,GAJA4B,GAAiB5B,CAAI,IACrB,QAAQ,MAAM,6BAA6BA,EAAK,qBAAqBwB,eAAuB,EAC5F,MAAM,KAAK,cAAcF,EAAUC,EAAUC,EAAY,CAAC,GAE1DK,GAAgB7B,CAAI,EAAG,CAEvB,MAAMxD,EAAK,KAAK,UAAU,YAAY,YAAa,WAAW,EACxD,MAAAA,GAAI,MAAM,IAAI,CAChB,OAAQwD,EAAK,QACb,SAAU,KAAK,SACf,oBAAqB,KAAK,oBAC1B,aAAcA,EAAK,aACnB,UAAWA,EAAK,SAAA,CACnB,EACD,MAAMxD,GAAI,KACV,KAAK,aAAewD,EAAK,aACzB,KAAK,UAAYA,EAAK,UACtB,KAAK,KAAOA,EAAK,QAEzB,CAEA,MAAa,iBAAiB8B,EAAuC,CACjE,GAAI,KAAK,YACL,OAAO,KAAK,YAEZ,GAAA,CAAC,KAAK,SACN,MAAM,MAAM,4BAA4B,EAKxC,GAHC,KAAK,UACN,MAAM,KAAK,iBAEX,CAAC,KAAK,aACN,MAAM,MAAM,gCAAgC,EAEhD,MAAMhC,EAAO,MAAM,MAAM,GAAG,KAAK,sCAAsCgC,IAAU,CAC7E,QAAS,CACL,cAAiB,UAAU,KAAK,cACpC,CAAA,CACH,EACG,GAAA,CAAChC,EAAK,GAAI,CACV,GAAIA,EAAK,SAAW,KAAOA,EAAK,SAAW,IACvC,MAAO,GAEX,cAAQ,MAAMA,CAAI,EACZ,MAAM,qDAAqD,EAE/D,MAAAE,EAAO,MAAMF,EAAK,OACxBE,EAAK,WAAaA,EAAK,YAAY,QAAQ,SAAU,GAAG,KAAK,qCAAqC,EAClG,KAAK,YAAcA,EACnB,MAAMxD,EAAK,KAAK,UAAU,YAAY,YAAa,WAAW,EACxD,aAAAA,GAAI,MAAM,IAAI,CAChB,OAAQ,KAAK,KACb,UAAW,KAAK,UAChB,SAAU,KAAK,SACf,oBAAqB,KAAK,oBAC1B,aAAc,KAAK,aACnB,YAAawD,EAAK,YAClB,UAAWA,EAAK,UAAA,CACnB,EACD,MAAMxD,GAAI,KAEHwD,CACX,CACJ,CAEA,SAAS4B,GAAiBtJ,EAAkC,CACxD,OAAOA,EAAI,iBAAmB,MAClC,CAEA,SAASuJ,GAAgBvJ,EAAiC,CACtD,OAAOA,EAAI,eAAiB,MAChC,CAEA,SAASqJ,GAAYrJ,EAA6B,CAC9C,OAAOA,EAAI,UAAY,MAC3B,CAEa,MAAAyJ,GAAoC,MAAMzD,GAAa,WACvD0D,EAAgBC,gBAA4BF,EAAmB,EAGrE,SAASG,IAAW,CACjB,MAAAC,EAASC,aAAWJ,CAAa,EACjC,CAACpD,EAAOyD,CAAQ,EAAIC,EAAoB,SAAAH,EAAO,UAAU,EAE/DI,OAAAA,EAAAA,UAAU,IAAM,CAEN,MAAAC,EAAkB5D,GAAqB,CACzCyD,EAASzD,CAAK,CAAA,EAEX,OAAAuD,EAAA,GAAG,QAASK,CAAc,EAEjCL,EAAO,UAAU,EACV,IAAM,CACFA,EAAA,eAAe,QAASK,CAAc,CAAA,CAErD,EAAG,CAAE,CAAA,EACE5D,CACX,CAEO,SAAS6D,IAAY,CAClB,MAAAN,EAASC,aAAWJ,CAAa,EACjC,CAACU,EAAiBC,CAAkB,EAAIL,EAE1C,SAAAH,EAAO,oBAAoB,EAE/BI,OAAAA,EAAAA,UAAU,IAAM,CAEN,MAAAC,EAAkBI,GAAsB,CACvBD,EAAAR,EAAO,oBAAoB,CAAA,EAE3C,OAAAA,EAAA,GAAG,QAASK,CAAc,EAEjCL,EAAO,UAAU,EACV,IAAM,CACFA,EAAA,eAAe,QAASK,CAAc,CAAA,CAErD,EAAG,CAAE,CAAA,EACEE,CACX,CAGO,SAASG,IAAa,CACnB,MAAAV,EAASC,aAAWJ,CAAa,EACjC,CAACc,EAASC,CAAU,EAAIT,WAAuB,CACjD,YAAaH,EAAO,MAAQ,SAAA,CAC/B,EAEDI,OAAAA,EAAAA,UAAU,IAAM,CACZJ,EAAO,iBAAiBA,EAAO,IAAK,EAAE,KAAMW,GAAY,CAC/CA,EAAQ,cACTA,EAAQ,YAAcX,EAAO,MAAQ,WAEzCY,EAAWD,CAAO,CAAA,CACrB,CACL,EAAG,CAAE,CAAA,EACEA,CACX","x_google_ignoreList":[2,3,4]}